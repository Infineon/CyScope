ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"main.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	DMA_Channel_1_Chan,1,1
  19              		.comm	DMA_Channel_1_TD,1,4
  20              		.comm	DMA_Channel_2_Chan,1,1
  21              		.comm	DMA_Channel_2_TD,1,4
  22              		.comm	Channel_1_Data,2048,4
  23              		.comm	Channel_2_Data,2048,4
  24              		.comm	szTempBuffer,64,4
  25              		.comm	cCharsReceived,1,1
  26              		.comm	szCommandsBuffer,4096,4
  27              		.comm	iRead,2,2
  28              		.comm	iWrite,2,2
  29              		.comm	cCommandsReady,2,2
  30              		.comm	szCommand,64,4
  31              		.comm	bCommandReady,1,1
  32              		.comm	preamp_a,1,1
  33              		.comm	preamp_b,1,1
  34              		.comm	trigger_source,1,1
  35              		.comm	preamp_trig,1,1
  36              		.comm	USB_Out_Buffer,64,4
  37              		.comm	Waveform_Buffer,256,4
  38              		.comm	Waveform_Temp_Buffer,256,4
  39              		.global	wave_gain
  40              		.bss
  41              		.type	wave_gain, %object
  42              		.size	wave_gain, 1
  43              	wave_gain:
  44 0000 00       		.space	1
  45              		.global	wave_offset
  46              		.type	wave_offset, %object
  47              		.size	wave_offset, 1
  48              	wave_offset:
  49 0001 00       		.space	1
  50              		.comm	Digital_Input_Status_Last,1,1
  51              		.comm	Digital_AutoUpdate,1,1
  52              		.section	.rodata
  53              		.align	2
  54              	.LC0:
  55 0000 2000     		.ascii	" \000"
  56 0002 0000     		.align	2
  57              	.LC1:
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 2


  58 0004 2A537973 		.ascii	"*Syscomp CircuitGear V1.3\012\015\000"
  58      636F6D70 
  58      20436972 
  58      63756974 
  58      47656172 
  59              		.align	2
  60              	.LC2:
  61 0020 25687500 		.ascii	"%hu\000"
  62              		.global	__aeabi_ui2f
  63              		.global	__aeabi_fmul
  64              		.global	__aeabi_f2d
  65              		.global	__aeabi_ddiv
  66              		.global	__aeabi_dadd
  67              		.global	__aeabi_d2f
  68              		.global	__aeabi_fcmpgt
  69              		.global	__aeabi_f2uiz
  70              		.global	__aeabi_dmul
  71              		.global	__aeabi_fdiv
  72              		.global	__aeabi_i2d
  73              		.global	__aeabi_fcmple
  74              		.global	__aeabi_fcmpge
  75              		.global	__aeabi_dsub
  76              		.global	__aeabi_d2uiz
  77              		.align	2
  78              	.LC3:
  79 0024 4572726F 		.ascii	"Error: Unrecognized Scope Command\012\015\000"
  79      723A2055 
  79      6E726563 
  79      6F676E69 
  79      7A656420 
  80              		.align	2
  81              	.LC4:
  82 0048 4572726F 		.ascii	"Error: Unknown Command\012\015\000"
  82      723A2055 
  82      6E6B6E6F 
  82      776E2043 
  82      6F6D6D61 
  83 0061 000000   		.section	.text.main,"ax",%progbits
  84              		.align	2
  85              		.global	main
  86              		.thumb
  87              		.thumb_func
  88              		.type	main, %function
  89              	main:
  90              	.LFB63:
  91              		.file 1 "main.c"
   1:main.c        **** /* ========================================
   2:main.c        ****  *
   3:main.c        ****  * Copyright Cypress Semiconductor, 2016
   4:main.c        ****  * All Rights Reserved
   5:main.c        ****  * UNPUBLISHED, LICENSED SOFTWARE.
   6:main.c        ****  *
   7:main.c        ****  * CONFIDENTIAL AND PROPRIETARY INFORMATION
   8:main.c        ****  * WHICH IS THE PROPERTY OF Cypress Semiconductor.
   9:main.c        ****  *
  10:main.c        ****  * ========================================
  11:main.c        **** */
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 3


  12:main.c        **** #include <device.h>
  13:main.c        **** #include <string.h>
  14:main.c        **** #include <stdio.h>
  15:main.c        **** 
  16:main.c        **** void DMA_Config(void);
  17:main.c        **** void Hardware_Config(void);
  18:main.c        **** uint16 GetLastSampleIndex(uint8 chHandle);
  19:main.c        **** void CommandCheck(void);
  20:main.c        **** void PutString(char * string);  // actually checks to see if the CDC device is ready before sending
  21:main.c        **** void PutChar(char Data);
  22:main.c        **** 
  23:main.c        **** // 2047 is the max buffer size in samples
  24:main.c        **** #define BUFFER_SIZE 1024
  25:main.c        **** 
  26:main.c        **** // trigger setup control register definitions
  27:main.c        **** #define FALLING_EDGE_TRIGGERED 0x01
  28:main.c        **** #define RISING_EDGE_TRIGGERED 0x02
  29:main.c        **** #define EITHER_EDGE_TRIGGERED 0x04
  30:main.c        **** #define EXTERNAL_TRIGGERED 0x08
  31:main.c        **** 
  32:main.c        **** #define TRIGGER_MASK 0x0F
  33:main.c        **** 
  34:main.c        **** #define MANUAL_TRIGGER 0x10
  35:main.c        **** #define TRIGGER_ARM 0x40
  36:main.c        **** #define RESET_PWM 0x80
  37:main.c        **** 
  38:main.c        **** // analog mux channel selection defines
  39:main.c        **** #define SCOPE_CHANNEL_1 0
  40:main.c        **** #define SCOPE_CHANNEL_2 1
  41:main.c        **** 
  42:main.c        **** // status register defines
  43:main.c        **** #define COMP_LEVEL 0x01
  44:main.c        **** #define TRIGGERED 0x02
  45:main.c        **** #define CAPTURE_COMPLETE 0x04
  46:main.c        **** 
  47:main.c        **** // Wave_Control control register definitions
  48:main.c        **** #define WAVE_SELECT_MASK 0x01
  49:main.c        **** #define WAVE_SELECT_WAVE 0x00
  50:main.c        **** #define WAVE_SELECT_NOISE 0x01
  51:main.c        **** 
  52:main.c        **** /* DMA Configuration for DMA_Channel_1 */
  53:main.c        **** #define DMA_Channel_1_BYTES_PER_BURST 2
  54:main.c        **** #define DMA_Channel_1_REQUEST_PER_BURST 1
  55:main.c        **** #define DMA_Channel_1_SRC_BASE (CYDEV_PERIPH_BASE)
  56:main.c        **** #define DMA_Channel_1_DST_BASE (CYDEV_SRAM_BASE)
  57:main.c        **** 
  58:main.c        **** /* DMA Configuration for DMA_Channel_2 */
  59:main.c        **** #define DMA_Channel_2_BYTES_PER_BURST 2
  60:main.c        **** #define DMA_Channel_2_REQUEST_PER_BURST 1
  61:main.c        **** #define DMA_Channel_2_SRC_BASE (CYDEV_PERIPH_BASE)
  62:main.c        **** #define DMA_Channel_2_DST_BASE (CYDEV_SRAM_BASE)
  63:main.c        **** 
  64:main.c        **** /* Variable declarations for DMA_Channel_1 */
  65:main.c        **** /* Move these variable declarations to the top of the function */
  66:main.c        **** uint8 DMA_Channel_1_Chan;
  67:main.c        **** uint8 DMA_Channel_1_TD[1];
  68:main.c        **** 
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 4


  69:main.c        **** /* Variable declarations for DMA_Channel_2 */
  70:main.c        **** /* Move these variable declarations to the top of the function */
  71:main.c        **** uint8 DMA_Channel_2_Chan;
  72:main.c        **** uint8 DMA_Channel_2_TD[1];
  73:main.c        **** 
  74:main.c        **** // RAM data arrays for storing the sampled data
  75:main.c        **** uint16 Channel_1_Data[BUFFER_SIZE];
  76:main.c        **** uint16 Channel_2_Data[BUFFER_SIZE];
  77:main.c        **** 
  78:main.c        **** // USB UART variables
  79:main.c        **** #define COMMAND_BUFFER_SIZE 64
  80:main.c        **** char szTempBuffer[COMMAND_BUFFER_SIZE];
  81:main.c        **** uint8 cCharsReceived;
  82:main.c        **** 
  83:main.c        **** #define CIRCULAR_BUFFER_SIZE 4096
  84:main.c        **** char szCommandsBuffer[CIRCULAR_BUFFER_SIZE]; // need to make this many times bigger to deal with th
  85:main.c        **** uint16 iRead, iWrite;
  86:main.c        **** uint16 cCommandsReady;
  87:main.c        **** 
  88:main.c        **** char szCommand[COMMAND_BUFFER_SIZE];
  89:main.c        **** uint8 bCommandReady;
  90:main.c        **** 
  91:main.c        **** // scope status variable
  92:main.c        **** uint8 preamp_a, preamp_b, trigger_source, preamp_trig;
  93:main.c        **** 
  94:main.c        **** // for dumping data out (its 64 bytes, but if you want anything less, it has to be a multiple of 4)
  95:main.c        **** // also a good idea to make it a multiple of the ADC buffer size, defined above
  96:main.c        **** #define USBUART_BUFFER_SIZE 64
  97:main.c        **** uint8 USB_Out_Buffer[USBUART_BUFFER_SIZE];
  98:main.c        **** 
  99:main.c        **** // Waveform generator variables
 100:main.c        **** #define WAVEFORM_BUFFER_SIZE 256
 101:main.c        **** uint8 Waveform_Buffer[WAVEFORM_BUFFER_SIZE];
 102:main.c        **** uint8 Waveform_Temp_Buffer[WAVEFORM_BUFFER_SIZE];
 103:main.c        **** uint8 wave_gain = 0;
 104:main.c        **** uint8 wave_offset = 0;
 105:main.c        **** 
 106:main.c        **** // digital input last state variable
 107:main.c        **** uint8 Digital_Input_Status_Last;
 108:main.c        **** uint8 Digital_AutoUpdate;
 109:main.c        **** 
 110:main.c        **** // For the SAR ADC to run at 18MHz, it *must* have a 50% duty cycle. 
 111:main.c        **** // There are 3 frequencies from the PLL that satisfy
 112:main.c        **** // generating an 18 Mhz clock from integer divides off the PLL: 36 Mhz
 113:main.c        **** // 54 Mhz and 72 Mhz.  Of these three choices, 54 Mhz requires a divide of
 114:main.c        **** // 3 which does not produce a 50% duty cycle.
 115:main.c        **** 
 116:main.c        **** int main()
 117:main.c        **** {
  92              		.loc 1 117 0
  93              		.cfi_startproc
  94              		@ args = 0, pretend = 0, frame = 32
  95              		@ frame_needed = 1, uses_anonymous_args = 0
  96 0000 B0B5     		push	{r4, r5, r7, lr}
  97              		.cfi_def_cfa_offset 16
  98              		.cfi_offset 4, -16
  99              		.cfi_offset 5, -12
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 5


 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 88B0     		sub	sp, sp, #32
 103              		.cfi_def_cfa_offset 48
 104 0004 00AF     		add	r7, sp, #0
 105              		.cfi_def_cfa_register 7
 118:main.c        **** 	uint8 status;
 119:main.c        **** 	uint16 ending_offset;
 120:main.c        **** 	char * psz;
 121:main.c        **** 	uint16 avar, bvar, i;
 122:main.c        **** 	uint32 phase_int;
 123:main.c        **** 	float freq;
 124:main.c        **** 	float cvar;
 125:main.c        ****     float wave_temp;
 126:main.c        ****  
 127:main.c        ****     Hardware_Config();
 106              		.loc 1 127 0
 107 0006 FFF7FEFF 		bl	Hardware_Config
 128:main.c        ****     DMA_Config();
 108              		.loc 1 128 0
 109 000a FFF7FEFF 		bl	DMA_Config
 110              	.L111:
 129:main.c        **** 
 130:main.c        ****     for(;;)
 131:main.c        ****     {
 132:main.c        **** 	
 133:main.c        **** 		CommandCheck();
 111              		.loc 1 133 0
 112 000e FFF7FEFF 		bl	CommandCheck
 134:main.c        **** 		
 135:main.c        **** 		if(bCommandReady != 0)
 113              		.loc 1 135 0
 114 0012 994B     		ldr	r3, .L119
 115 0014 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 116 0016 002B     		cmp	r3, #0
 117 0018 00F0AD86 		beq	.L2
 136:main.c        **** 		{
 137:main.c        **** 			psz = strtok(szCommand, " ");
 118              		.loc 1 137 0
 119 001c 9748     		ldr	r0, .L119+4
 120 001e 9849     		ldr	r1, .L119+8
 121 0020 FFF7FEFF 		bl	strtok
 122 0024 F860     		str	r0, [r7, #12]
 138:main.c        **** 			if(*psz == 'i')
 123              		.loc 1 138 0
 124 0026 FB68     		ldr	r3, [r7, #12]
 125 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 126 002a 692B     		cmp	r3, #105
 127 002c 04D1     		bne	.L3
 139:main.c        **** 			{
 140:main.c        **** 				// it all started here.  NOTE!  \n\r THE ORDER MATTERS!
 141:main.c        **** 				PutString("*Syscomp CircuitGear V1.3\n\r");
 128              		.loc 1 141 0
 129 002e 9548     		ldr	r0, .L119+12
 130 0030 FFF7FEFF 		bl	PutString
 131 0034 00F09CBE 		b	.L4
 132              	.L3:
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 6


 142:main.c        **** 			}
 143:main.c        **** 			else if(*psz == 'D')
 133              		.loc 1 143 0
 134 0038 FB68     		ldr	r3, [r7, #12]
 135 003a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 136 003c 442B     		cmp	r3, #68
 137 003e 40F0E680 		bne	.L5
 144:main.c        **** 			{
 145:main.c        **** 				// Digital I/O commands
 146:main.c        **** 				
 147:main.c        **** 				psz = strtok(0, " ");
 138              		.loc 1 147 0
 139 0042 0020     		movs	r0, #0
 140 0044 8E49     		ldr	r1, .L119+8
 141 0046 FFF7FEFF 		bl	strtok
 142 004a F860     		str	r0, [r7, #12]
 148:main.c        **** 				if(*psz == 'O')
 143              		.loc 1 148 0
 144 004c FB68     		ldr	r3, [r7, #12]
 145 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 146 0050 4F2B     		cmp	r3, #79
 147 0052 11D1     		bne	.L6
 149:main.c        **** 				{
 150:main.c        **** 					// Digital output
 151:main.c        **** 					// D O N, where N is the output byte value as an ascii 8 bit number
 152:main.c        **** 					psz = strtok(0, " ");
 148              		.loc 1 152 0
 149 0054 0020     		movs	r0, #0
 150 0056 8A49     		ldr	r1, .L119+8
 151 0058 FFF7FEFF 		bl	strtok
 152 005c F860     		str	r0, [r7, #12]
 153:main.c        **** 					sscanf(psz,"%hu", &avar);
 153              		.loc 1 153 0
 154 005e BB1C     		adds	r3, r7, #2
 155 0060 F868     		ldr	r0, [r7, #12]
 156 0062 8949     		ldr	r1, .L119+16
 157 0064 1A46     		mov	r2, r3
 158 0066 FFF7FEFF 		bl	sscanf
 154:main.c        **** 					
 155:main.c        **** 					Digital_Out_Control_Write((uint8) avar);
 159              		.loc 1 155 0
 160 006a 7B88     		ldrh	r3, [r7, #2]
 161 006c DBB2     		uxtb	r3, r3
 162 006e 1846     		mov	r0, r3
 163 0070 FFF7FEFF 		bl	Digital_Out_Control_Write
 164 0074 00F07CBE 		b	.L4
 165              	.L6:
 156:main.c        **** 				}
 157:main.c        **** 				else if(*psz == 'I')
 166              		.loc 1 157 0
 167 0078 FB68     		ldr	r3, [r7, #12]
 168 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 169 007c 492B     		cmp	r3, #73
 170 007e 0AD1     		bne	.L7
 158:main.c        **** 				{
 159:main.c        **** 					// reads digital inputs
 160:main.c        **** 					// returns Ix where x is an 8 bit (binary) value representing the status
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 7


 161:main.c        **** 					// of the digital input pins
 162:main.c        **** 					
 163:main.c        **** 					PutChar('I');
 171              		.loc 1 163 0
 172 0080 4920     		movs	r0, #73
 173 0082 FFF7FEFF 		bl	PutChar
 164:main.c        **** 					PutChar((uint8) Digital_Input_Status_Read());
 174              		.loc 1 164 0
 175 0086 FFF7FEFF 		bl	Digital_Input_Status_Read
 176 008a 0346     		mov	r3, r0
 177 008c 1846     		mov	r0, r3
 178 008e FFF7FEFF 		bl	PutChar
 179 0092 00F06DBE 		b	.L4
 180              	.L7:
 165:main.c        **** 				}
 166:main.c        **** 				else if(*psz == 'A')
 181              		.loc 1 166 0
 182 0096 FB68     		ldr	r3, [r7, #12]
 183 0098 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 184 009a 412B     		cmp	r3, #65
 185 009c 0DD1     		bne	.L8
 167:main.c        **** 				{
 168:main.c        **** 					Digital_AutoUpdate = 1;
 186              		.loc 1 168 0
 187 009e 7B4B     		ldr	r3, .L119+20
 188 00a0 0122     		movs	r2, #1
 189 00a2 1A70     		strb	r2, [r3]
 169:main.c        ****                     PutChar('I');
 190              		.loc 1 169 0
 191 00a4 4920     		movs	r0, #73
 192 00a6 FFF7FEFF 		bl	PutChar
 170:main.c        **** 					PutChar((uint8) Digital_Input_Status_Read());
 193              		.loc 1 170 0
 194 00aa FFF7FEFF 		bl	Digital_Input_Status_Read
 195 00ae 0346     		mov	r3, r0
 196 00b0 1846     		mov	r0, r3
 197 00b2 FFF7FEFF 		bl	PutChar
 198 00b6 00F05BBE 		b	.L4
 199              	.L8:
 171:main.c        **** 				}
 172:main.c        **** 				else if(*psz == 'a')
 200              		.loc 1 172 0
 201 00ba FB68     		ldr	r3, [r7, #12]
 202 00bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 203 00be 612B     		cmp	r3, #97
 204 00c0 04D1     		bne	.L9
 173:main.c        **** 				{
 174:main.c        **** 					Digital_AutoUpdate = 0;
 205              		.loc 1 174 0
 206 00c2 724B     		ldr	r3, .L119+20
 207 00c4 0022     		movs	r2, #0
 208 00c6 1A70     		strb	r2, [r3]
 209 00c8 00F052BE 		b	.L4
 210              	.L9:
 175:main.c        **** 				}
 176:main.c        **** 				else if(*psz == 'F')
 211              		.loc 1 176 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 8


 212 00cc FB68     		ldr	r3, [r7, #12]
 213 00ce 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 214 00d0 462B     		cmp	r3, #70
 215 00d2 5ED1     		bne	.L10
 177:main.c        **** 				{
 178:main.c        **** 					// set PWM output frequency
 179:main.c        **** 			    	// D F N where N is an 8 bit ascii value that corresponds to these frequencies
 180:main.c        **** 					// 0 72 Khz
 181:main.c        **** 					// 1 36 Khz
 182:main.c        **** 					// 2 9 Khz
 183:main.c        **** 					// 3 4.5 Khz
 184:main.c        **** 					// 4 1.125 Khz
 185:main.c        **** 					// 5 564 Hz
 186:main.c        **** 					// 6 281 Hz
 187:main.c        **** 					// 7 141 Hz
 188:main.c        **** 					// 8 70 Hz
 189:main.c        **** 					// 9 35 Hz
 190:main.c        **** 					// 10 - 255 disabled
 191:main.c        **** 					psz = strtok(0, " ");
 216              		.loc 1 191 0
 217 00d4 0020     		movs	r0, #0
 218 00d6 6A49     		ldr	r1, .L119+8
 219 00d8 FFF7FEFF 		bl	strtok
 220 00dc F860     		str	r0, [r7, #12]
 192:main.c        **** 					sscanf(psz,"%hu", &avar);
 221              		.loc 1 192 0
 222 00de BB1C     		adds	r3, r7, #2
 223 00e0 F868     		ldr	r0, [r7, #12]
 224 00e2 6949     		ldr	r1, .L119+16
 225 00e4 1A46     		mov	r2, r3
 226 00e6 FFF7FEFF 		bl	sscanf
 193:main.c        **** 					
 194:main.c        **** 					switch(avar)
 227              		.loc 1 194 0
 228 00ea 7B88     		ldrh	r3, [r7, #2]
 229 00ec 092B     		cmp	r3, #9
 230 00ee 4DD8     		bhi	.L118
 231 00f0 01A2     		adr	r2, .L13
 232 00f2 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 233 00f6 00BF     		.p2align 2
 234              	.L13:
 235 00f8 21010000 		.word	.L12+1
 236 00fc 2B010000 		.word	.L14+1
 237 0100 35010000 		.word	.L15+1
 238 0104 3F010000 		.word	.L16+1
 239 0108 49010000 		.word	.L17+1
 240 010c 53010000 		.word	.L18+1
 241 0110 5D010000 		.word	.L19+1
 242 0114 69010000 		.word	.L20+1
 243 0118 75010000 		.word	.L21+1
 244 011c 81010000 		.word	.L22+1
 245              		.p2align 1
 246              	.L12:
 195:main.c        **** 					{
 196:main.c        **** 						// GJL - change PWM period to 250 to get exact frequency
 197:main.c        ****                         case 0: // (36 Mhz / 250 (period of the PWM)) / 72 Khz = 2
 198:main.c        **** 							PWM_Clock_SetDividerValue(2);
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 9


 247              		.loc 1 198 0
 248 0120 0120     		movs	r0, #1
 249 0122 0121     		movs	r1, #1
 250 0124 FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 199:main.c        **** 							break;
 251              		.loc 1 199 0
 252 0128 31E0     		b	.L23
 253              	.L14:
 200:main.c        **** 							
 201:main.c        **** 						case 1:
 202:main.c        **** 							PWM_Clock_SetDividerValue(4);
 254              		.loc 1 202 0
 255 012a 0320     		movs	r0, #3
 256 012c 0121     		movs	r1, #1
 257 012e FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 203:main.c        **** 							break;
 258              		.loc 1 203 0
 259 0132 2CE0     		b	.L23
 260              	.L15:
 204:main.c        **** 							
 205:main.c        **** 						case 2:
 206:main.c        **** 							PWM_Clock_SetDividerValue(16);
 261              		.loc 1 206 0
 262 0134 0F20     		movs	r0, #15
 263 0136 0121     		movs	r1, #1
 264 0138 FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 207:main.c        **** 							break;
 265              		.loc 1 207 0
 266 013c 27E0     		b	.L23
 267              	.L16:
 208:main.c        **** 						
 209:main.c        **** 						case 3:
 210:main.c        **** 							PWM_Clock_SetDividerValue(32);
 268              		.loc 1 210 0
 269 013e 1F20     		movs	r0, #31
 270 0140 0121     		movs	r1, #1
 271 0142 FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 211:main.c        **** 							break;
 272              		.loc 1 211 0
 273 0146 22E0     		b	.L23
 274              	.L17:
 212:main.c        **** 							
 213:main.c        **** 						case 4:
 214:main.c        **** 							PWM_Clock_SetDividerValue(128);
 275              		.loc 1 214 0
 276 0148 7F20     		movs	r0, #127
 277 014a 0121     		movs	r1, #1
 278 014c FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 215:main.c        **** 							break;
 279              		.loc 1 215 0
 280 0150 1DE0     		b	.L23
 281              	.L18:
 216:main.c        **** 							
 217:main.c        **** 						case 5:
 218:main.c        **** 							PWM_Clock_SetDividerValue(255);
 282              		.loc 1 218 0
 283 0152 FE20     		movs	r0, #254
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 10


 284 0154 0121     		movs	r1, #1
 285 0156 FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 219:main.c        **** 							break;
 286              		.loc 1 219 0
 287 015a 18E0     		b	.L23
 288              	.L19:
 220:main.c        **** 							
 221:main.c        **** 						case 6:
 222:main.c        **** 							PWM_Clock_SetDividerValue(512);
 289              		.loc 1 222 0
 290 015c 40F2FF10 		movw	r0, #511
 291 0160 0121     		movs	r1, #1
 292 0162 FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 223:main.c        **** 							break;
 293              		.loc 1 223 0
 294 0166 12E0     		b	.L23
 295              	.L20:
 224:main.c        **** 							
 225:main.c        **** 						case 7:
 226:main.c        **** 							PWM_Clock_SetDividerValue(1021);
 296              		.loc 1 226 0
 297 0168 4FF47F70 		mov	r0, #1020
 298 016c 0121     		movs	r1, #1
 299 016e FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 227:main.c        **** 							break;
 300              		.loc 1 227 0
 301 0172 0CE0     		b	.L23
 302              	.L21:
 228:main.c        **** 							
 229:main.c        **** 						case 8:
 230:main.c        **** 							PWM_Clock_SetDividerValue(2057);
 303              		.loc 1 230 0
 304 0174 40F60800 		movw	r0, #2056
 305 0178 0121     		movs	r1, #1
 306 017a FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 231:main.c        **** 							break;
 307              		.loc 1 231 0
 308 017e 06E0     		b	.L23
 309              	.L22:
 232:main.c        **** 						
 233:main.c        **** 						case 9:
 234:main.c        **** 							PWM_Clock_SetDividerValue(4114);
 310              		.loc 1 234 0
 311 0180 41F21100 		movw	r0, #4113
 312 0184 0121     		movs	r1, #1
 313 0186 FFF7FEFF 		bl	PWM_Clock_SetDividerRegister
 235:main.c        **** 							break;
 314              		.loc 1 235 0
 315 018a 00E0     		b	.L23
 316              	.L118:
 236:main.c        **** 							
 237:main.c        **** 						default:
 238:main.c        **** 							//PWM_Stop();
 239:main.c        **** 							break;
 317              		.loc 1 239 0
 318 018c 00BF     		nop
 319              	.L23:
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 11


 320 018e 00F0EFBD 		b	.L4
 321              	.L10:
 240:main.c        **** 					}
 241:main.c        **** 				}
 242:main.c        **** 				else if(*psz == 'D')
 322              		.loc 1 242 0
 323 0192 FB68     		ldr	r3, [r7, #12]
 324 0194 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 325 0196 442B     		cmp	r3, #68
 326 0198 1BD1     		bne	.L24
 243:main.c        **** 				{
 244:main.c        **** 					// Set PWM Duty cycle
 245:main.c        **** 					// D D N where N is an 8 bit ascii value representing the duty cycle
 246:main.c        **** 					// from 0 to 255
 247:main.c        **** 					psz = strtok(0, " ");
 327              		.loc 1 247 0
 328 019a 0020     		movs	r0, #0
 329 019c 3849     		ldr	r1, .L119+8
 330 019e FFF7FEFF 		bl	strtok
 331 01a2 F860     		str	r0, [r7, #12]
 248:main.c        **** 					sscanf(psz,"%hu", &avar);
 332              		.loc 1 248 0
 333 01a4 BB1C     		adds	r3, r7, #2
 334 01a6 F868     		ldr	r0, [r7, #12]
 335 01a8 3749     		ldr	r1, .L119+16
 336 01aa 1A46     		mov	r2, r3
 337 01ac FFF7FEFF 		bl	sscanf
 249:main.c        **** 					// GJL: Limit upper compare value to 249 since period is 249
 250:main.c        ****                     if(avar > 249)
 338              		.loc 1 250 0
 339 01b0 7B88     		ldrh	r3, [r7, #2]
 340 01b2 F92B     		cmp	r3, #249
 341 01b4 01D9     		bls	.L25
 251:main.c        ****                     {
 252:main.c        ****                         avar = 249;
 342              		.loc 1 252 0
 343 01b6 F923     		movs	r3, #249
 344 01b8 7B80     		strh	r3, [r7, #2]	@ movhi
 345              	.L25:
 253:main.c        ****                     }
 254:main.c        **** 					Digital_PWM_WriteCompare1((uint8) avar);
 346              		.loc 1 254 0
 347 01ba 7B88     		ldrh	r3, [r7, #2]
 348 01bc DBB2     		uxtb	r3, r3
 349 01be 1846     		mov	r0, r3
 350 01c0 FFF7FEFF 		bl	Digital_PWM_WriteCompare1
 255:main.c        **** 					Digital_PWM_WriteCompare2((uint8) avar);
 351              		.loc 1 255 0
 352 01c4 7B88     		ldrh	r3, [r7, #2]
 353 01c6 DBB2     		uxtb	r3, r3
 354 01c8 1846     		mov	r0, r3
 355 01ca FFF7FEFF 		bl	Digital_PWM_WriteCompare2
 356 01ce 00F0CFBD 		b	.L4
 357              	.L24:
 256:main.c        **** 				}
 257:main.c        **** 				else if(*psz == '!')
 358              		.loc 1 257 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 12


 359 01d2 FB68     		ldr	r3, [r7, #12]
 360 01d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 361 01d6 212B     		cmp	r3, #33
 362 01d8 40F0CA85 		bne	.L4
 258:main.c        **** 				{
 259:main.c        **** 					// interrupt line configuration.  not implemented yet
 260:main.c        **** 					// sends back a '!' character when the interrupt condition is met
 261:main.c        **** 					// D ! M where M is the mode:
 262:main.c        **** 					// M = D : Disable
 263:main.c        **** 					// M = R : Rising Edge
 264:main.c        **** 					// M = F : Falling Edge
 265:main.c        **** 					// M = H : High Level
 266:main.c        **** 					// M = L : Low Level
 267:main.c        **** 					psz = strtok(0, " ");
 363              		.loc 1 267 0
 364 01dc 0020     		movs	r0, #0
 365 01de 2849     		ldr	r1, .L119+8
 366 01e0 FFF7FEFF 		bl	strtok
 367 01e4 F860     		str	r0, [r7, #12]
 268:main.c        **** 					
 269:main.c        **** 					if(*psz == 'D')
 368              		.loc 1 269 0
 369 01e6 FB68     		ldr	r3, [r7, #12]
 370 01e8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 371 01ea 442B     		cmp	r3, #68
 372 01ec 00F0C085 		beq	.L4
 270:main.c        **** 					{
 271:main.c        **** 					}
 272:main.c        **** 					else if(*psz == 'R')
 373              		.loc 1 272 0
 374 01f0 FB68     		ldr	r3, [r7, #12]
 375 01f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 376 01f4 522B     		cmp	r3, #82
 377 01f6 00F0BB85 		beq	.L4
 273:main.c        **** 					{
 274:main.c        **** 					}
 275:main.c        **** 					else if(*psz == 'F')
 378              		.loc 1 275 0
 379 01fa FB68     		ldr	r3, [r7, #12]
 380 01fc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 381 01fe 462B     		cmp	r3, #70
 382 0200 00F0B685 		beq	.L4
 276:main.c        **** 					{
 277:main.c        **** 					}
 278:main.c        **** 					else if(*psz == 'H')
 383              		.loc 1 278 0
 384 0204 FB68     		ldr	r3, [r7, #12]
 385 0206 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 386 0208 482B     		cmp	r3, #72
 387 020a 00F0B1BD 		b	.L4
 388              	.L5:
 279:main.c        **** 					{
 280:main.c        **** 					}
 281:main.c        **** 					else if(*psz == 'L')
 282:main.c        **** 					{
 283:main.c        **** 					}
 284:main.c        **** 					
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 13


 285:main.c        **** 					// if trigger condition is met, send back the '!' character
 286:main.c        **** 					//PutChar('!');
 287:main.c        **** 				}
 288:main.c        **** 			}
 289:main.c        **** 			else if(*psz == 'W')
 389              		.loc 1 289 0
 390 020e FB68     		ldr	r3, [r7, #12]
 391 0210 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 392 0212 572B     		cmp	r3, #87
 393 0214 40F02682 		bne	.L26
 290:main.c        **** 			{
 291:main.c        **** 				// waveform generator commands
 292:main.c        **** 				
 293:main.c        **** 				psz = strtok(0, " ");
 394              		.loc 1 293 0
 395 0218 0020     		movs	r0, #0
 396 021a 1949     		ldr	r1, .L119+8
 397 021c FFF7FEFF 		bl	strtok
 398 0220 F860     		str	r0, [r7, #12]
 294:main.c        **** 				if(*psz == 'S')
 399              		.loc 1 294 0
 400 0222 FB68     		ldr	r3, [r7, #12]
 401 0224 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 402 0226 532B     		cmp	r3, #83
 403 0228 1ED1     		bne	.L27
 295:main.c        **** 				{
 296:main.c        **** 					// sample data into the buffer
 297:main.c        **** 					// command is W S ADDR DATA
 298:main.c        **** 					// ADDR is the 8 bit address 0 - 255
 299:main.c        **** 					// DATA is the waveform amplitude 0 - 255
 300:main.c        **** 					psz = strtok(0, " ");
 404              		.loc 1 300 0
 405 022a 0020     		movs	r0, #0
 406 022c 1449     		ldr	r1, .L119+8
 407 022e FFF7FEFF 		bl	strtok
 408 0232 F860     		str	r0, [r7, #12]
 301:main.c        **** 					sscanf(psz,"%hu", &avar);
 409              		.loc 1 301 0
 410 0234 BB1C     		adds	r3, r7, #2
 411 0236 F868     		ldr	r0, [r7, #12]
 412 0238 1349     		ldr	r1, .L119+16
 413 023a 1A46     		mov	r2, r3
 414 023c FFF7FEFF 		bl	sscanf
 302:main.c        **** 					bvar = avar;  // something is wacky with sscanf.  if I dont move the data into bvar, then on t
 415              		.loc 1 302 0
 416 0240 7B88     		ldrh	r3, [r7, #2]	@ movhi
 417 0242 FB83     		strh	r3, [r7, #30]	@ movhi
 303:main.c        **** 					// if I use another variable, avar gets reset to zero!
 304:main.c        **** 					// got the address
 305:main.c        **** 					
 306:main.c        **** 					psz = strtok(0, " ");
 418              		.loc 1 306 0
 419 0244 0020     		movs	r0, #0
 420 0246 0E49     		ldr	r1, .L119+8
 421 0248 FFF7FEFF 		bl	strtok
 422 024c F860     		str	r0, [r7, #12]
 307:main.c        **** 					sscanf(psz,"%hu", &avar);
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 14


 423              		.loc 1 307 0
 424 024e BB1C     		adds	r3, r7, #2
 425 0250 F868     		ldr	r0, [r7, #12]
 426 0252 0D49     		ldr	r1, .L119+16
 427 0254 1A46     		mov	r2, r3
 428 0256 FFF7FEFF 		bl	sscanf
 308:main.c        **** 					// got the data
 309:main.c        **** 					
 310:main.c        **** 					// store it in the buffer
 311:main.c        **** 					Waveform_Temp_Buffer[bvar] = avar;
 429              		.loc 1 311 0
 430 025a FB8B     		ldrh	r3, [r7, #30]
 431 025c 7A88     		ldrh	r2, [r7, #2]
 432 025e D1B2     		uxtb	r1, r2
 433 0260 0B4A     		ldr	r2, .L119+24
 434 0262 D154     		strb	r1, [r2, r3]
 435 0264 00F084BD 		b	.L4
 436              	.L27:
 312:main.c        **** 				}
 313:main.c        **** 				else if(*psz == 'P')
 437              		.loc 1 313 0
 438 0268 FB68     		ldr	r3, [r7, #12]
 439 026a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 440 026c 502B     		cmp	r3, #80
 441 026e 63D1     		bne	.L29
 314:main.c        **** 				{
 315:main.c        **** 					// program the waveform by copying it into the array that the waveform generator uses
 316:main.c        **** 					for(i = 0; i < WAVEFORM_BUFFER_SIZE; i++)
 442              		.loc 1 316 0
 443 0270 0023     		movs	r3, #0
 444 0272 BB83     		strh	r3, [r7, #28]	@ movhi
 445 0274 5BE0     		b	.L30
 446              	.L120:
 447 0276 00BF     		.align	2
 448              	.L119:
 449 0278 00000000 		.word	bCommandReady
 450 027c 00000000 		.word	szCommand
 451 0280 00000000 		.word	.LC0
 452 0284 04000000 		.word	.LC1
 453 0288 20000000 		.word	.LC2
 454 028c 00000000 		.word	Digital_AutoUpdate
 455 0290 00000000 		.word	Waveform_Temp_Buffer
 456              	.L33:
 317:main.c        **** 					{
 318:main.c        **** 						// GJL - add offset and max checking
 319:main.c        ****                         wave_temp = (((float) Waveform_Temp_Buffer[i]) * ((float)wave_gain)/255.0) 
 457              		.loc 1 319 0
 458 0294 BB8B     		ldrh	r3, [r7, #28]
 459 0296 AA4A     		ldr	r2, .L121+8
 460 0298 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 461 029a 1846     		mov	r0, r3
 462 029c FFF7FEFF 		bl	__aeabi_ui2f
 463 02a0 0446     		mov	r4, r0
 464 02a2 A84B     		ldr	r3, .L121+12
 465 02a4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 466 02a6 1846     		mov	r0, r3
 467 02a8 FFF7FEFF 		bl	__aeabi_ui2f
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 15


 468 02ac 0346     		mov	r3, r0
 469 02ae 2046     		mov	r0, r4
 470 02b0 1946     		mov	r1, r3
 471 02b2 FFF7FEFF 		bl	__aeabi_fmul
 472 02b6 0346     		mov	r3, r0
 473 02b8 1846     		mov	r0, r3
 474 02ba FFF7FEFF 		bl	__aeabi_f2d
 475 02be 0246     		mov	r2, r0
 476 02c0 0B46     		mov	r3, r1
 477 02c2 1046     		mov	r0, r2
 478 02c4 1946     		mov	r1, r3
 479 02c6 9CA3     		adr	r3, .L121
 480 02c8 D3E90023 		ldrd	r2, [r3]
 481 02cc FFF7FEFF 		bl	__aeabi_ddiv
 482 02d0 0246     		mov	r2, r0
 483 02d2 0B46     		mov	r3, r1
 484 02d4 1446     		mov	r4, r2
 485 02d6 1D46     		mov	r5, r3
 486 02d8 9B4B     		ldr	r3, .L121+16
 487 02da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 488 02dc 1846     		mov	r0, r3
 489 02de FFF7FEFF 		bl	__aeabi_ui2f
 490 02e2 0346     		mov	r3, r0
 491 02e4 1846     		mov	r0, r3
 492 02e6 FFF7FEFF 		bl	__aeabi_f2d
 493 02ea 0246     		mov	r2, r0
 494 02ec 0B46     		mov	r3, r1
 495 02ee 2046     		mov	r0, r4
 496 02f0 2946     		mov	r1, r5
 497 02f2 FFF7FEFF 		bl	__aeabi_dadd
 498 02f6 0246     		mov	r2, r0
 499 02f8 0B46     		mov	r3, r1
 500 02fa 1046     		mov	r0, r2
 501 02fc 1946     		mov	r1, r3
 502 02fe FFF7FEFF 		bl	__aeabi_d2f
 503 0302 0346     		mov	r3, r0
 504 0304 3B61     		str	r3, [r7, #16]	@ float
 320:main.c        ****                         if(wave_temp > 255.0)
 505              		.loc 1 320 0
 506 0306 3869     		ldr	r0, [r7, #16]	@ float
 507 0308 9049     		ldr	r1, .L121+20
 508 030a FFF7FEFF 		bl	__aeabi_fcmpgt
 509 030e 0346     		mov	r3, r0
 510 0310 002B     		cmp	r3, #0
 511 0312 01D0     		beq	.L31
 321:main.c        ****                         {
 322:main.c        ****                             wave_temp = 255.0;
 512              		.loc 1 322 0
 513 0314 8D4B     		ldr	r3, .L121+20
 514 0316 3B61     		str	r3, [r7, #16]	@ float
 515              	.L31:
 323:main.c        ****                         }
 324:main.c        ****                         Waveform_Buffer[i] = (uint8) wave_temp;
 516              		.loc 1 324 0 discriminator 2
 517 0318 BC8B     		ldrh	r4, [r7, #28]
 518 031a 3869     		ldr	r0, [r7, #16]	@ float
 519 031c FFF7FEFF 		bl	__aeabi_f2uiz
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 16


 520 0320 0346     		mov	r3, r0
 521 0322 DAB2     		uxtb	r2, r3
 522 0324 8A4B     		ldr	r3, .L121+24
 523 0326 1A55     		strb	r2, [r3, r4]
 316:main.c        **** 					{
 524              		.loc 1 316 0 discriminator 2
 525 0328 BB8B     		ldrh	r3, [r7, #28]
 526 032a 0133     		adds	r3, r3, #1
 527 032c BB83     		strh	r3, [r7, #28]	@ movhi
 528              	.L30:
 316:main.c        **** 					{
 529              		.loc 1 316 0 is_stmt 0 discriminator 1
 530 032e BB8B     		ldrh	r3, [r7, #28]
 531 0330 FF2B     		cmp	r3, #255
 532 0332 AFD9     		bls	.L33
 533 0334 00F01CBD 		b	.L4
 534              	.L29:
 325:main.c        **** 					}   
 326:main.c        **** 				}
 327:main.c        **** 				else if(*psz == 'A')
 535              		.loc 1 327 0 is_stmt 1
 536 0338 FB68     		ldr	r3, [r7, #12]
 537 033a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 538 033c 412B     		cmp	r3, #65
 539 033e 63D1     		bne	.L34
 328:main.c        **** 				{
 329:main.c        **** 					// set the waveform amplitude
 330:main.c        **** 					// W A A0, where A0 is the a bit amplitude, 0 = 0%, 255 = 100%
 331:main.c        **** 					// program the waveform amplitude by copying it into the array that the waveform generator use
 332:main.c        **** 					// but scale it during the copy
 333:main.c        **** 					
 334:main.c        **** 					psz = strtok(0, " ");
 540              		.loc 1 334 0
 541 0340 0020     		movs	r0, #0
 542 0342 8449     		ldr	r1, .L121+28
 543 0344 FFF7FEFF 		bl	strtok
 544 0348 F860     		str	r0, [r7, #12]
 335:main.c        **** 					sscanf(psz,"%hu", &avar);
 545              		.loc 1 335 0
 546 034a BB1C     		adds	r3, r7, #2
 547 034c F868     		ldr	r0, [r7, #12]
 548 034e 8249     		ldr	r1, .L121+32
 549 0350 1A46     		mov	r2, r3
 550 0352 FFF7FEFF 		bl	sscanf
 336:main.c        **** 					
 337:main.c        **** 					wave_gain = avar;
 551              		.loc 1 337 0
 552 0356 7B88     		ldrh	r3, [r7, #2]
 553 0358 DAB2     		uxtb	r2, r3
 554 035a 7A4B     		ldr	r3, .L121+12
 555 035c 1A70     		strb	r2, [r3]
 338:main.c        **** 					
 339:main.c        **** 					for(i = 0; i < WAVEFORM_BUFFER_SIZE; i++)
 556              		.loc 1 339 0
 557 035e 0023     		movs	r3, #0
 558 0360 BB83     		strh	r3, [r7, #28]	@ movhi
 559 0362 4CE0     		b	.L35
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 17


 560              	.L38:
 340:main.c        **** 					{
 341:main.c        **** 						// GJL - add offset and max checking
 342:main.c        ****                         wave_temp = (((float) Waveform_Temp_Buffer[i]) * ((float)wave_gain)/255.0) 
 561              		.loc 1 342 0
 562 0364 BB8B     		ldrh	r3, [r7, #28]
 563 0366 764A     		ldr	r2, .L121+8
 564 0368 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 565 036a 1846     		mov	r0, r3
 566 036c FFF7FEFF 		bl	__aeabi_ui2f
 567 0370 0446     		mov	r4, r0
 568 0372 744B     		ldr	r3, .L121+12
 569 0374 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 570 0376 1846     		mov	r0, r3
 571 0378 FFF7FEFF 		bl	__aeabi_ui2f
 572 037c 0346     		mov	r3, r0
 573 037e 2046     		mov	r0, r4
 574 0380 1946     		mov	r1, r3
 575 0382 FFF7FEFF 		bl	__aeabi_fmul
 576 0386 0346     		mov	r3, r0
 577 0388 1846     		mov	r0, r3
 578 038a FFF7FEFF 		bl	__aeabi_f2d
 579 038e 0246     		mov	r2, r0
 580 0390 0B46     		mov	r3, r1
 581 0392 1046     		mov	r0, r2
 582 0394 1946     		mov	r1, r3
 583 0396 68A3     		adr	r3, .L121
 584 0398 D3E90023 		ldrd	r2, [r3]
 585 039c FFF7FEFF 		bl	__aeabi_ddiv
 586 03a0 0246     		mov	r2, r0
 587 03a2 0B46     		mov	r3, r1
 588 03a4 1446     		mov	r4, r2
 589 03a6 1D46     		mov	r5, r3
 590 03a8 674B     		ldr	r3, .L121+16
 591 03aa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 592 03ac 1846     		mov	r0, r3
 593 03ae FFF7FEFF 		bl	__aeabi_ui2f
 594 03b2 0346     		mov	r3, r0
 595 03b4 1846     		mov	r0, r3
 596 03b6 FFF7FEFF 		bl	__aeabi_f2d
 597 03ba 0246     		mov	r2, r0
 598 03bc 0B46     		mov	r3, r1
 599 03be 2046     		mov	r0, r4
 600 03c0 2946     		mov	r1, r5
 601 03c2 FFF7FEFF 		bl	__aeabi_dadd
 602 03c6 0246     		mov	r2, r0
 603 03c8 0B46     		mov	r3, r1
 604 03ca 1046     		mov	r0, r2
 605 03cc 1946     		mov	r1, r3
 606 03ce FFF7FEFF 		bl	__aeabi_d2f
 607 03d2 0346     		mov	r3, r0
 608 03d4 3B61     		str	r3, [r7, #16]	@ float
 343:main.c        ****                         if(wave_temp > 255.0)
 609              		.loc 1 343 0
 610 03d6 3869     		ldr	r0, [r7, #16]	@ float
 611 03d8 5C49     		ldr	r1, .L121+20
 612 03da FFF7FEFF 		bl	__aeabi_fcmpgt
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 18


 613 03de 0346     		mov	r3, r0
 614 03e0 002B     		cmp	r3, #0
 615 03e2 01D0     		beq	.L36
 344:main.c        ****                         {
 345:main.c        ****                             wave_temp = 255.0;
 616              		.loc 1 345 0
 617 03e4 594B     		ldr	r3, .L121+20
 618 03e6 3B61     		str	r3, [r7, #16]	@ float
 619              	.L36:
 346:main.c        ****                         }
 347:main.c        ****                         Waveform_Buffer[i] = (uint8) wave_temp;
 620              		.loc 1 347 0 discriminator 2
 621 03e8 BC8B     		ldrh	r4, [r7, #28]
 622 03ea 3869     		ldr	r0, [r7, #16]	@ float
 623 03ec FFF7FEFF 		bl	__aeabi_f2uiz
 624 03f0 0346     		mov	r3, r0
 625 03f2 DAB2     		uxtb	r2, r3
 626 03f4 564B     		ldr	r3, .L121+24
 627 03f6 1A55     		strb	r2, [r3, r4]
 339:main.c        **** 					{
 628              		.loc 1 339 0 discriminator 2
 629 03f8 BB8B     		ldrh	r3, [r7, #28]
 630 03fa 0133     		adds	r3, r3, #1
 631 03fc BB83     		strh	r3, [r7, #28]	@ movhi
 632              	.L35:
 339:main.c        **** 					{
 633              		.loc 1 339 0 is_stmt 0 discriminator 1
 634 03fe BB8B     		ldrh	r3, [r7, #28]
 635 0400 FF2B     		cmp	r3, #255
 636 0402 AFD9     		bls	.L38
 637 0404 00F0B4BC 		b	.L4
 638              	.L34:
 348:main.c        **** 					}              
 349:main.c        ****                     
 350:main.c        **** 				}
 351:main.c        **** 				// GJL - add offset functionality
 352:main.c        ****                 else if(*psz == 'O')
 639              		.loc 1 352 0 is_stmt 1
 640 0408 FB68     		ldr	r3, [r7, #12]
 641 040a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 642 040c 4F2B     		cmp	r3, #79
 643 040e 63D1     		bne	.L39
 353:main.c        ****                 {
 354:main.c        ****                     // set waveform offset
 355:main.c        ****                     // W O O0 where O0 is the offset - 0 = 0%, 255 = 100%
 356:main.c        ****                     // program teh offset by copying it into the array that the waveform generator 
 357:main.c        ****                     // but adjust the values upwards during the copy
 358:main.c        ****                     
 359:main.c        ****                     psz = strtok(0, " ");
 644              		.loc 1 359 0
 645 0410 0020     		movs	r0, #0
 646 0412 5049     		ldr	r1, .L121+28
 647 0414 FFF7FEFF 		bl	strtok
 648 0418 F860     		str	r0, [r7, #12]
 360:main.c        **** 					sscanf(psz,"%hu", &avar);
 649              		.loc 1 360 0
 650 041a BB1C     		adds	r3, r7, #2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 19


 651 041c F868     		ldr	r0, [r7, #12]
 652 041e 4E49     		ldr	r1, .L121+32
 653 0420 1A46     		mov	r2, r3
 654 0422 FFF7FEFF 		bl	sscanf
 361:main.c        **** 					
 362:main.c        **** 					wave_offset = avar;
 655              		.loc 1 362 0
 656 0426 7B88     		ldrh	r3, [r7, #2]
 657 0428 DAB2     		uxtb	r2, r3
 658 042a 474B     		ldr	r3, .L121+16
 659 042c 1A70     		strb	r2, [r3]
 363:main.c        **** 					
 364:main.c        **** 					for(i = 0; i < WAVEFORM_BUFFER_SIZE; i++)
 660              		.loc 1 364 0
 661 042e 0023     		movs	r3, #0
 662 0430 BB83     		strh	r3, [r7, #28]	@ movhi
 663 0432 4CE0     		b	.L40
 664              	.L43:
 365:main.c        **** 					{
 366:main.c        **** 						// GJL temp - add offset
 367:main.c        ****                         wave_temp = (((float) Waveform_Temp_Buffer[i]) * ((float)wave_gain)/255.0) 
 665              		.loc 1 367 0
 666 0434 BB8B     		ldrh	r3, [r7, #28]
 667 0436 424A     		ldr	r2, .L121+8
 668 0438 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 669 043a 1846     		mov	r0, r3
 670 043c FFF7FEFF 		bl	__aeabi_ui2f
 671 0440 0446     		mov	r4, r0
 672 0442 404B     		ldr	r3, .L121+12
 673 0444 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 674 0446 1846     		mov	r0, r3
 675 0448 FFF7FEFF 		bl	__aeabi_ui2f
 676 044c 0346     		mov	r3, r0
 677 044e 2046     		mov	r0, r4
 678 0450 1946     		mov	r1, r3
 679 0452 FFF7FEFF 		bl	__aeabi_fmul
 680 0456 0346     		mov	r3, r0
 681 0458 1846     		mov	r0, r3
 682 045a FFF7FEFF 		bl	__aeabi_f2d
 683 045e 0246     		mov	r2, r0
 684 0460 0B46     		mov	r3, r1
 685 0462 1046     		mov	r0, r2
 686 0464 1946     		mov	r1, r3
 687 0466 34A3     		adr	r3, .L121
 688 0468 D3E90023 		ldrd	r2, [r3]
 689 046c FFF7FEFF 		bl	__aeabi_ddiv
 690 0470 0246     		mov	r2, r0
 691 0472 0B46     		mov	r3, r1
 692 0474 1446     		mov	r4, r2
 693 0476 1D46     		mov	r5, r3
 694 0478 334B     		ldr	r3, .L121+16
 695 047a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 696 047c 1846     		mov	r0, r3
 697 047e FFF7FEFF 		bl	__aeabi_ui2f
 698 0482 0346     		mov	r3, r0
 699 0484 1846     		mov	r0, r3
 700 0486 FFF7FEFF 		bl	__aeabi_f2d
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 20


 701 048a 0246     		mov	r2, r0
 702 048c 0B46     		mov	r3, r1
 703 048e 2046     		mov	r0, r4
 704 0490 2946     		mov	r1, r5
 705 0492 FFF7FEFF 		bl	__aeabi_dadd
 706 0496 0246     		mov	r2, r0
 707 0498 0B46     		mov	r3, r1
 708 049a 1046     		mov	r0, r2
 709 049c 1946     		mov	r1, r3
 710 049e FFF7FEFF 		bl	__aeabi_d2f
 711 04a2 0346     		mov	r3, r0
 712 04a4 3B61     		str	r3, [r7, #16]	@ float
 368:main.c        ****                         if(wave_temp > 255.0)
 713              		.loc 1 368 0
 714 04a6 3869     		ldr	r0, [r7, #16]	@ float
 715 04a8 2849     		ldr	r1, .L121+20
 716 04aa FFF7FEFF 		bl	__aeabi_fcmpgt
 717 04ae 0346     		mov	r3, r0
 718 04b0 002B     		cmp	r3, #0
 719 04b2 01D0     		beq	.L41
 369:main.c        ****                         {
 370:main.c        ****                             wave_temp = 255.0;
 720              		.loc 1 370 0
 721 04b4 254B     		ldr	r3, .L121+20
 722 04b6 3B61     		str	r3, [r7, #16]	@ float
 723              	.L41:
 371:main.c        ****                         }
 372:main.c        ****                         Waveform_Buffer[i] = (uint8) wave_temp;
 724              		.loc 1 372 0 discriminator 2
 725 04b8 BC8B     		ldrh	r4, [r7, #28]
 726 04ba 3869     		ldr	r0, [r7, #16]	@ float
 727 04bc FFF7FEFF 		bl	__aeabi_f2uiz
 728 04c0 0346     		mov	r3, r0
 729 04c2 DAB2     		uxtb	r2, r3
 730 04c4 224B     		ldr	r3, .L121+24
 731 04c6 1A55     		strb	r2, [r3, r4]
 364:main.c        **** 					{
 732              		.loc 1 364 0 discriminator 2
 733 04c8 BB8B     		ldrh	r3, [r7, #28]
 734 04ca 0133     		adds	r3, r3, #1
 735 04cc BB83     		strh	r3, [r7, #28]	@ movhi
 736              	.L40:
 364:main.c        **** 					{
 737              		.loc 1 364 0 is_stmt 0 discriminator 1
 738 04ce BB8B     		ldrh	r3, [r7, #28]
 739 04d0 FF2B     		cmp	r3, #255
 740 04d2 AFD9     		bls	.L43
 741 04d4 00F04CBC 		b	.L4
 742              	.L39:
 373:main.c        **** 					}              
 374:main.c        ****                 }
 375:main.c        ****                 else if(*psz == 'W')
 743              		.loc 1 375 0 is_stmt 1
 744 04d8 FB68     		ldr	r3, [r7, #12]
 745 04da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 746 04dc 572B     		cmp	r3, #87
 747 04de 10D1     		bne	.L44
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 21


 376:main.c        **** 				{
 377:main.c        **** 					// select the waveform output
 378:main.c        **** 					Wave_Control_Write(Wave_Control_Read() & ~WAVE_SELECT_MASK);
 748              		.loc 1 378 0
 749 04e0 FFF7FEFF 		bl	Wave_Control_Read
 750 04e4 0346     		mov	r3, r0
 751 04e6 23F00103 		bic	r3, r3, #1
 752 04ea DBB2     		uxtb	r3, r3
 753 04ec 1846     		mov	r0, r3
 754 04ee FFF7FEFF 		bl	Wave_Control_Write
 379:main.c        **** 					Wave_Control_Write(Wave_Control_Read() | WAVE_SELECT_WAVE);
 755              		.loc 1 379 0
 756 04f2 FFF7FEFF 		bl	Wave_Control_Read
 757 04f6 0346     		mov	r3, r0
 758 04f8 1846     		mov	r0, r3
 759 04fa FFF7FEFF 		bl	Wave_Control_Write
 760 04fe 00F037BC 		b	.L4
 761              	.L44:
 380:main.c        **** 				}
 381:main.c        **** 				else if(*psz == 'N')
 762              		.loc 1 381 0
 763 0502 FB68     		ldr	r3, [r7, #12]
 764 0504 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 765 0506 4E2B     		cmp	r3, #78
 766 0508 28D1     		bne	.L45
 382:main.c        **** 				{
 383:main.c        **** 					// select the noise output
 384:main.c        **** 					Wave_Control_Write(Wave_Control_Read() & ~WAVE_SELECT_MASK);
 767              		.loc 1 384 0
 768 050a FFF7FEFF 		bl	Wave_Control_Read
 769 050e 0346     		mov	r3, r0
 770 0510 23F00103 		bic	r3, r3, #1
 771 0514 DBB2     		uxtb	r3, r3
 772 0516 1846     		mov	r0, r3
 773 0518 FFF7FEFF 		bl	Wave_Control_Write
 385:main.c        **** 					Wave_Control_Write(Wave_Control_Read() | WAVE_SELECT_NOISE);
 774              		.loc 1 385 0
 775 051c FFF7FEFF 		bl	Wave_Control_Read
 776 0520 0346     		mov	r3, r0
 777 0522 43F00103 		orr	r3, r3, #1
 778 0526 DBB2     		uxtb	r3, r3
 779 0528 1846     		mov	r0, r3
 780 052a FFF7FEFF 		bl	Wave_Control_Write
 781 052e 00F01FBC 		b	.L4
 782              	.L122:
 783 0532 00BFAFF3 		.align	3
 783      0080
 784              	.L121:
 785 0538 00000000 		.word	0
 786 053c 00E06F40 		.word	1081073664
 787 0540 00000000 		.word	Waveform_Temp_Buffer
 788 0544 00000000 		.word	wave_gain
 789 0548 00000000 		.word	wave_offset
 790 054c 00007F43 		.word	1132396544
 791 0550 00000000 		.word	Waveform_Buffer
 792 0554 00000000 		.word	.LC0
 793 0558 20000000 		.word	.LC2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 22


 794              	.L45:
 386:main.c        **** 				}
 387:main.c        **** 				else if(*psz == 'F')
 795              		.loc 1 387 0
 796 055c FB68     		ldr	r3, [r7, #12]
 797 055e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 798 0560 462B     		cmp	r3, #70
 799 0562 40F00584 		bne	.L4
 388:main.c        **** 				{
 389:main.c        **** 					// set the frequency output of the waveform generator
 390:main.c        **** 					// best thing to have here is an actual DDS in the hardware
 391:main.c        **** 					// but to get this working, I'm just going to fake it by setting
 392:main.c        **** 					// the clock divider.  It wont work for everything, but it should be
 393:main.c        **** 					// passable.  The command is W F F3 F2 F1 F0 where Fn are 8 bit ascii
 394:main.c        **** 					// numbers that are combined into a 32 bit phase accumulator value
 395:main.c        **** 					// phase value = desired output frequency / 0.09313225746 Hz
 396:main.c        **** 					
 397:main.c        **** 					psz = strtok(0, " ");
 800              		.loc 1 397 0
 801 0566 0020     		movs	r0, #0
 802 0568 B149     		ldr	r1, .L123+24
 803 056a FFF7FEFF 		bl	strtok
 804 056e F860     		str	r0, [r7, #12]
 398:main.c        **** 					sscanf(psz,"%hu", &avar);
 805              		.loc 1 398 0
 806 0570 BB1C     		adds	r3, r7, #2
 807 0572 F868     		ldr	r0, [r7, #12]
 808 0574 AF49     		ldr	r1, .L123+28
 809 0576 1A46     		mov	r2, r3
 810 0578 FFF7FEFF 		bl	sscanf
 399:main.c        **** 					phase_int = ((uint32) avar)*16777216;
 811              		.loc 1 399 0
 812 057c 7B88     		ldrh	r3, [r7, #2]
 813 057e 1B06     		lsls	r3, r3, #24
 814 0580 BB61     		str	r3, [r7, #24]
 400:main.c        **** 					
 401:main.c        **** 					psz = strtok(0, " ");
 815              		.loc 1 401 0
 816 0582 0020     		movs	r0, #0
 817 0584 AA49     		ldr	r1, .L123+24
 818 0586 FFF7FEFF 		bl	strtok
 819 058a F860     		str	r0, [r7, #12]
 402:main.c        **** 					sscanf(psz,"%hu", &avar);
 820              		.loc 1 402 0
 821 058c BB1C     		adds	r3, r7, #2
 822 058e F868     		ldr	r0, [r7, #12]
 823 0590 A849     		ldr	r1, .L123+28
 824 0592 1A46     		mov	r2, r3
 825 0594 FFF7FEFF 		bl	sscanf
 403:main.c        **** 					phase_int += ((uint32) avar)*65536;
 826              		.loc 1 403 0
 827 0598 7B88     		ldrh	r3, [r7, #2]
 828 059a 1B04     		lsls	r3, r3, #16
 829 059c BA69     		ldr	r2, [r7, #24]
 830 059e 1344     		add	r3, r3, r2
 831 05a0 BB61     		str	r3, [r7, #24]
 404:main.c        **** 					
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 23


 405:main.c        **** 					psz = strtok(0, " ");
 832              		.loc 1 405 0
 833 05a2 0020     		movs	r0, #0
 834 05a4 A249     		ldr	r1, .L123+24
 835 05a6 FFF7FEFF 		bl	strtok
 836 05aa F860     		str	r0, [r7, #12]
 406:main.c        **** 					sscanf(psz,"%hu", &avar);
 837              		.loc 1 406 0
 838 05ac BB1C     		adds	r3, r7, #2
 839 05ae F868     		ldr	r0, [r7, #12]
 840 05b0 A049     		ldr	r1, .L123+28
 841 05b2 1A46     		mov	r2, r3
 842 05b4 FFF7FEFF 		bl	sscanf
 407:main.c        **** 					phase_int += ((uint32) avar)*256;
 843              		.loc 1 407 0
 844 05b8 7B88     		ldrh	r3, [r7, #2]
 845 05ba 1B02     		lsls	r3, r3, #8
 846 05bc BA69     		ldr	r2, [r7, #24]
 847 05be 1344     		add	r3, r3, r2
 848 05c0 BB61     		str	r3, [r7, #24]
 408:main.c        **** 					
 409:main.c        **** 					psz = strtok(0, " ");
 849              		.loc 1 409 0
 850 05c2 0020     		movs	r0, #0
 851 05c4 9A49     		ldr	r1, .L123+24
 852 05c6 FFF7FEFF 		bl	strtok
 853 05ca F860     		str	r0, [r7, #12]
 410:main.c        **** 					sscanf(psz,"%hu", &avar);
 854              		.loc 1 410 0
 855 05cc BB1C     		adds	r3, r7, #2
 856 05ce F868     		ldr	r0, [r7, #12]
 857 05d0 9849     		ldr	r1, .L123+28
 858 05d2 1A46     		mov	r2, r3
 859 05d4 FFF7FEFF 		bl	sscanf
 411:main.c        **** 					phase_int += ((uint32) avar);
 860              		.loc 1 411 0
 861 05d8 7B88     		ldrh	r3, [r7, #2]
 862 05da 1A46     		mov	r2, r3
 863 05dc BB69     		ldr	r3, [r7, #24]
 864 05de 1344     		add	r3, r3, r2
 865 05e0 BB61     		str	r3, [r7, #24]
 412:main.c        **** 					
 413:main.c        **** 					freq = ((float) phase_int)*.09313225746;
 866              		.loc 1 413 0
 867 05e2 B869     		ldr	r0, [r7, #24]
 868 05e4 FFF7FEFF 		bl	__aeabi_ui2f
 869 05e8 0346     		mov	r3, r0
 870 05ea 1846     		mov	r0, r3
 871 05ec FFF7FEFF 		bl	__aeabi_f2d
 872 05f0 0246     		mov	r2, r0
 873 05f2 0B46     		mov	r3, r1
 874 05f4 1046     		mov	r0, r2
 875 05f6 1946     		mov	r1, r3
 876 05f8 87A3     		adr	r3, .L123
 877 05fa D3E90023 		ldrd	r2, [r3]
 878 05fe FFF7FEFF 		bl	__aeabi_dmul
 879 0602 0246     		mov	r2, r0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 24


 880 0604 0B46     		mov	r3, r1
 881 0606 1046     		mov	r0, r2
 882 0608 1946     		mov	r1, r3
 883 060a FFF7FEFF 		bl	__aeabi_d2f
 884 060e 0346     		mov	r3, r0
 885 0610 BB60     		str	r3, [r7, #8]	@ float
 414:main.c        **** 					
 415:main.c        **** 					// calculate the clock divider
 416:main.c        **** 					phase_int = (int32) (36000000.0/((float) WAVEFORM_BUFFER_SIZE))/freq;
 886              		.loc 1 416 0
 887 0612 8948     		ldr	r0, .L123+32
 888 0614 B968     		ldr	r1, [r7, #8]	@ float
 889 0616 FFF7FEFF 		bl	__aeabi_fdiv
 890 061a 0346     		mov	r3, r0
 891 061c 1846     		mov	r0, r3
 892 061e FFF7FEFF 		bl	__aeabi_f2uiz
 893 0622 0346     		mov	r3, r0
 894 0624 BB61     		str	r3, [r7, #24]
 417:main.c        **** 					
 418:main.c        **** 					if(phase_int >= 65535)
 895              		.loc 1 418 0
 896 0626 BB69     		ldr	r3, [r7, #24]
 897 0628 4FF6FE72 		movw	r2, #65534
 898 062c 9342     		cmp	r3, r2
 899 062e 03D9     		bls	.L46
 419:main.c        **** 					{
 420:main.c        **** 						phase_int = 65535;
 900              		.loc 1 420 0
 901 0630 4FF6FF73 		movw	r3, #65535
 902 0634 BB61     		str	r3, [r7, #24]
 903 0636 04E0     		b	.L47
 904              	.L46:
 421:main.c        **** 					}
 422:main.c        **** 					else if(phase_int <= 15) // anything less than this and the DMA doesn't have time to execute
 905              		.loc 1 422 0
 906 0638 BB69     		ldr	r3, [r7, #24]
 907 063a 0F2B     		cmp	r3, #15
 908 063c 01D8     		bhi	.L47
 423:main.c        **** 					{
 424:main.c        **** 						phase_int = 15;
 909              		.loc 1 424 0
 910 063e 0F23     		movs	r3, #15
 911 0640 BB61     		str	r3, [r7, #24]
 912              	.L47:
 425:main.c        **** 					}
 426:main.c        **** 					
 427:main.c        **** 					Wave_Clock_SetDividerValue((uint16) phase_int);
 913              		.loc 1 427 0
 914 0642 BB69     		ldr	r3, [r7, #24]
 915 0644 9BB2     		uxth	r3, r3
 916 0646 013B     		subs	r3, r3, #1
 917 0648 9BB2     		uxth	r3, r3
 918 064a 1846     		mov	r0, r3
 919 064c 0121     		movs	r1, #1
 920 064e FFF7FEFF 		bl	Wave_Clock_SetDividerRegister
 428:main.c        ****                     Noise_Clock_SetDividerValue((uint16) phase_int);
 921              		.loc 1 428 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 25


 922 0652 BB69     		ldr	r3, [r7, #24]
 923 0654 9BB2     		uxth	r3, r3
 924 0656 013B     		subs	r3, r3, #1
 925 0658 9BB2     		uxth	r3, r3
 926 065a 1846     		mov	r0, r3
 927 065c 0121     		movs	r1, #1
 928 065e FFF7FEFF 		bl	Noise_Clock_SetDividerRegister
 929 0662 85E3     		b	.L4
 930              	.L26:
 429:main.c        **** 					
 430:main.c        **** 				}
 431:main.c        **** 			}
 432:main.c        **** 			else if(*psz == 'S')
 931              		.loc 1 432 0
 932 0664 FB68     		ldr	r3, [r7, #12]
 933 0666 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 934 0668 532B     		cmp	r3, #83
 935 066a 40F07E83 		bne	.L48
 433:main.c        **** 			{
 434:main.c        **** 				// scope commands
 435:main.c        **** 				
 436:main.c        **** 				psz = strtok(0, " ");
 936              		.loc 1 436 0
 937 066e 0020     		movs	r0, #0
 938 0670 6F49     		ldr	r1, .L123+24
 939 0672 FFF7FEFF 		bl	strtok
 940 0676 F860     		str	r0, [r7, #12]
 437:main.c        **** 				if(*psz == 'O')
 941              		.loc 1 437 0
 942 0678 FB68     		ldr	r3, [r7, #12]
 943 067a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 944 067c 4F2B     		cmp	r3, #79
 945 067e 0FD1     		bne	.L49
 438:main.c        **** 				{
 439:main.c        **** 					// read offset from EEPROM command
 440:main.c        **** 					PutChar('O');
 946              		.loc 1 440 0
 947 0680 4F20     		movs	r0, #79
 948 0682 FFF7FEFF 		bl	PutChar
 441:main.c        **** 					PutChar(128); // A
 949              		.loc 1 441 0
 950 0686 8020     		movs	r0, #128
 951 0688 FFF7FEFF 		bl	PutChar
 442:main.c        **** 					PutChar(128); // a
 952              		.loc 1 442 0
 953 068c 8020     		movs	r0, #128
 954 068e FFF7FEFF 		bl	PutChar
 443:main.c        **** 					PutChar(128); // B
 955              		.loc 1 443 0
 956 0692 8020     		movs	r0, #128
 957 0694 FFF7FEFF 		bl	PutChar
 444:main.c        **** 					PutChar(128); // b
 958              		.loc 1 444 0
 959 0698 8020     		movs	r0, #128
 960 069a FFF7FEFF 		bl	PutChar
 961 069e 67E3     		b	.L4
 962              	.L49:
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 26


 445:main.c        **** 					
 446:main.c        **** 				}
 447:main.c        **** 				else if(*psz == 'T')
 963              		.loc 1 447 0
 964 06a0 FB68     		ldr	r3, [r7, #12]
 965 06a2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 966 06a4 542B     		cmp	r3, #84
 967 06a6 7CD1     		bne	.L51
 448:main.c        **** 				{
 449:main.c        **** 					// set the trigger level
 450:main.c        **** 					// data comes back as two ascii strings, each representing an 8 bit value
 451:main.c        **** 					// S T T_HIGH T_LOW where T_HIGH and T_LOW represent a 10 bit number
 452:main.c        **** 					// the trigger is set by the following equation:
 453:main.c        **** 					// 511 - Gain*Trigger_Voltage/0.052421484375 (383 without the offsets set to 128)
 454:main.c        **** 					psz = strtok(0, " ");
 968              		.loc 1 454 0
 969 06a8 0020     		movs	r0, #0
 970 06aa 6149     		ldr	r1, .L123+24
 971 06ac FFF7FEFF 		bl	strtok
 972 06b0 F860     		str	r0, [r7, #12]
 455:main.c        **** 					sscanf(psz,"%hu", &avar);
 973              		.loc 1 455 0
 974 06b2 BB1C     		adds	r3, r7, #2
 975 06b4 F868     		ldr	r0, [r7, #12]
 976 06b6 5F49     		ldr	r1, .L123+28
 977 06b8 1A46     		mov	r2, r3
 978 06ba FFF7FEFF 		bl	sscanf
 456:main.c        **** 					bvar = avar*256;
 979              		.loc 1 456 0
 980 06be 7B88     		ldrh	r3, [r7, #2]
 981 06c0 1B02     		lsls	r3, r3, #8
 982 06c2 FB83     		strh	r3, [r7, #30]	@ movhi
 457:main.c        **** 					
 458:main.c        **** 					psz = strtok(0, " ");
 983              		.loc 1 458 0
 984 06c4 0020     		movs	r0, #0
 985 06c6 5A49     		ldr	r1, .L123+24
 986 06c8 FFF7FEFF 		bl	strtok
 987 06cc F860     		str	r0, [r7, #12]
 459:main.c        **** 					sscanf(psz,"%hu", &avar);
 988              		.loc 1 459 0
 989 06ce BB1C     		adds	r3, r7, #2
 990 06d0 F868     		ldr	r0, [r7, #12]
 991 06d2 5849     		ldr	r1, .L123+28
 992 06d4 1A46     		mov	r2, r3
 993 06d6 FFF7FEFF 		bl	sscanf
 460:main.c        **** 					bvar += avar;
 994              		.loc 1 460 0
 995 06da 7A88     		ldrh	r2, [r7, #2]
 996 06dc FB8B     		ldrh	r3, [r7, #30]	@ movhi
 997 06de 1344     		add	r3, r3, r2
 998 06e0 FB83     		strh	r3, [r7, #30]	@ movhi
 461:main.c        **** 					
 462:main.c        **** 					// voltage = (511 - Value)/Gain * 0.05242 -> (511-Value)/1*0.05242/0.016(mv per bit, 4 volt Vd
 463:main.c        **** 					// there are 2 gain options, 1x and 10x.
 464:main.c        **** 					if(trigger_source == SCOPE_CHANNEL_1)
 999              		.loc 1 464 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 27


 1000 06e2 564B     		ldr	r3, .L123+36
 1001 06e4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1002 06e6 002B     		cmp	r3, #0
 1003 06e8 04D1     		bne	.L52
 465:main.c        **** 					{
 466:main.c        **** 						preamp_trig = preamp_a;
 1004              		.loc 1 466 0
 1005 06ea 554B     		ldr	r3, .L123+40
 1006 06ec 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1007 06ee 554B     		ldr	r3, .L123+44
 1008 06f0 1A70     		strb	r2, [r3]
 1009 06f2 03E0     		b	.L53
 1010              	.L52:
 467:main.c        **** 					}
 468:main.c        **** 					else
 469:main.c        **** 					{
 470:main.c        **** 						preamp_trig = preamp_b;
 1011              		.loc 1 470 0
 1012 06f4 544B     		ldr	r3, .L123+48
 1013 06f6 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1014 06f8 524B     		ldr	r3, .L123+44
 1015 06fa 1A70     		strb	r2, [r3]
 1016              	.L53:
 471:main.c        **** 					}
 472:main.c        **** 					
 473:main.c        **** 					if(preamp_trig == 1)
 1017              		.loc 1 473 0
 1018 06fc 514B     		ldr	r3, .L123+44
 1019 06fe 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1020 0700 012B     		cmp	r3, #1
 1021 0702 18D1     		bne	.L54
 474:main.c        **** 					{
 475:main.c        **** 						cvar = (511-bvar)*3.3093; // 3.27635 (before emperical correction value)
 1022              		.loc 1 475 0
 1023 0704 FB8B     		ldrh	r3, [r7, #30]
 1024 0706 C3F5FF73 		rsb	r3, r3, #510
 1025 070a 0133     		adds	r3, r3, #1
 1026 070c 1846     		mov	r0, r3
 1027 070e FFF7FEFF 		bl	__aeabi_i2d
 1028 0712 0246     		mov	r2, r0
 1029 0714 0B46     		mov	r3, r1
 1030 0716 1046     		mov	r0, r2
 1031 0718 1946     		mov	r1, r3
 1032 071a 41A3     		adr	r3, .L123+8
 1033 071c D3E90023 		ldrd	r2, [r3]
 1034 0720 FFF7FEFF 		bl	__aeabi_dmul
 1035 0724 0246     		mov	r2, r0
 1036 0726 0B46     		mov	r3, r1
 1037 0728 1046     		mov	r0, r2
 1038 072a 1946     		mov	r1, r3
 1039 072c FFF7FEFF 		bl	__aeabi_d2f
 1040 0730 0346     		mov	r3, r0
 1041 0732 7B61     		str	r3, [r7, #20]	@ float
 1042 0734 17E0     		b	.L55
 1043              	.L54:
 476:main.c        **** 					}
 477:main.c        **** 					else
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 28


 478:main.c        **** 					{
 479:main.c        ****                         //cvar = (511-bvar)*0.37685; // .327635 (before empirical correction value)
 480:main.c        ****                         cvar = (511-bvar)*0.75668;
 1044              		.loc 1 480 0
 1045 0736 FB8B     		ldrh	r3, [r7, #30]
 1046 0738 C3F5FF73 		rsb	r3, r3, #510
 1047 073c 0133     		adds	r3, r3, #1
 1048 073e 1846     		mov	r0, r3
 1049 0740 FFF7FEFF 		bl	__aeabi_i2d
 1050 0744 0246     		mov	r2, r0
 1051 0746 0B46     		mov	r3, r1
 1052 0748 1046     		mov	r0, r2
 1053 074a 1946     		mov	r1, r3
 1054 074c 36A3     		adr	r3, .L123+16
 1055 074e D3E90023 		ldrd	r2, [r3]
 1056 0752 FFF7FEFF 		bl	__aeabi_dmul
 1057 0756 0246     		mov	r2, r0
 1058 0758 0B46     		mov	r3, r1
 1059 075a 1046     		mov	r0, r2
 1060 075c 1946     		mov	r1, r3
 1061 075e FFF7FEFF 		bl	__aeabi_d2f
 1062 0762 0346     		mov	r3, r0
 1063 0764 7B61     		str	r3, [r7, #20]	@ float
 1064              	.L55:
 481:main.c        **** 					}
 482:main.c        **** 					
 483:main.c        **** 					if(cvar <= 0.0)
 1065              		.loc 1 483 0
 1066 0766 7869     		ldr	r0, [r7, #20]	@ float
 1067 0768 4FF00001 		mov	r1, #0
 1068 076c FFF7FEFF 		bl	__aeabi_fcmple
 1069 0770 0346     		mov	r3, r0
 1070 0772 002B     		cmp	r3, #0
 1071 0774 03D0     		beq	.L117
 484:main.c        **** 					{
 485:main.c        **** 						cvar = 0.0;
 1072              		.loc 1 485 0
 1073 0776 4FF00003 		mov	r3, #0
 1074 077a 7B61     		str	r3, [r7, #20]	@ float
 1075 077c 08E0     		b	.L58
 1076              	.L117:
 486:main.c        **** 					}
 487:main.c        **** 					else if(cvar >= 255.0)
 1077              		.loc 1 487 0
 1078 077e 7869     		ldr	r0, [r7, #20]	@ float
 1079 0780 3249     		ldr	r1, .L123+52
 1080 0782 FFF7FEFF 		bl	__aeabi_fcmpge
 1081 0786 0346     		mov	r3, r0
 1082 0788 002B     		cmp	r3, #0
 1083 078a 01D0     		beq	.L58
 488:main.c        **** 					{
 489:main.c        **** 						cvar = 255.0;
 1084              		.loc 1 489 0
 1085 078c 2F4B     		ldr	r3, .L123+52
 1086 078e 7B61     		str	r3, [r7, #20]	@ float
 1087              	.L58:
 490:main.c        **** 					}
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 29


 491:main.c        **** 					Vtrigger_SetValue((uint8) cvar);
 1088              		.loc 1 491 0
 1089 0790 7869     		ldr	r0, [r7, #20]	@ float
 1090 0792 FFF7FEFF 		bl	__aeabi_f2uiz
 1091 0796 0346     		mov	r3, r0
 1092 0798 DBB2     		uxtb	r3, r3
 1093 079a 1846     		mov	r0, r3
 1094 079c FFF7FEFF 		bl	Vtrigger_SetValue
 1095 07a0 E6E2     		b	.L4
 1096              	.L51:
 492:main.c        **** 				}
 493:main.c        **** 				else if(*psz == 'C')
 1097              		.loc 1 493 0
 1098 07a2 FB68     		ldr	r3, [r7, #12]
 1099 07a4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1100 07a6 432B     		cmp	r3, #67
 1101 07a8 52D1     		bne	.L60
 494:main.c        **** 				{
 495:main.c        **** 					// Post trigger buffer size
 496:main.c        **** 					// data comes back as two ascii strings, each representing an 8 bit value
 497:main.c        **** 					// S C C_HIGH C_LOW where C_HIGH and C_LOW represent a 10 bit number
 498:main.c        **** 					psz = strtok(0, " ");
 1102              		.loc 1 498 0
 1103 07aa 0020     		movs	r0, #0
 1104 07ac 2049     		ldr	r1, .L123+24
 1105 07ae FFF7FEFF 		bl	strtok
 1106 07b2 F860     		str	r0, [r7, #12]
 499:main.c        **** 					sscanf(psz,"%hu", &avar);
 1107              		.loc 1 499 0
 1108 07b4 BB1C     		adds	r3, r7, #2
 1109 07b6 F868     		ldr	r0, [r7, #12]
 1110 07b8 1E49     		ldr	r1, .L123+28
 1111 07ba 1A46     		mov	r2, r3
 1112 07bc FFF7FEFF 		bl	sscanf
 500:main.c        **** 					bvar = avar*256;
 1113              		.loc 1 500 0
 1114 07c0 7B88     		ldrh	r3, [r7, #2]
 1115 07c2 1B02     		lsls	r3, r3, #8
 1116 07c4 FB83     		strh	r3, [r7, #30]	@ movhi
 501:main.c        **** 					
 502:main.c        **** 					psz = strtok(0, " ");
 1117              		.loc 1 502 0
 1118 07c6 0020     		movs	r0, #0
 1119 07c8 1949     		ldr	r1, .L123+24
 1120 07ca FFF7FEFF 		bl	strtok
 1121 07ce F860     		str	r0, [r7, #12]
 503:main.c        **** 					sscanf(psz,"%hu", &avar);
 1122              		.loc 1 503 0
 1123 07d0 BB1C     		adds	r3, r7, #2
 1124 07d2 F868     		ldr	r0, [r7, #12]
 1125 07d4 1749     		ldr	r1, .L123+28
 1126 07d6 1A46     		mov	r2, r3
 1127 07d8 FFF7FEFF 		bl	sscanf
 504:main.c        **** 					bvar += avar;
 1128              		.loc 1 504 0
 1129 07dc 7A88     		ldrh	r2, [r7, #2]
 1130 07de FB8B     		ldrh	r3, [r7, #30]	@ movhi
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 30


 1131 07e0 1344     		add	r3, r3, r2
 1132 07e2 FB83     		strh	r3, [r7, #30]	@ movhi
 505:main.c        **** 					
 506:main.c        **** 					if(bvar >= (BUFFER_SIZE-1))
 1133              		.loc 1 506 0
 1134 07e4 FB8B     		ldrh	r3, [r7, #30]
 1135 07e6 40F2FE32 		movw	r2, #1022
 1136 07ea 9342     		cmp	r3, r2
 1137 07ec 03D9     		bls	.L61
 507:main.c        **** 					{
 508:main.c        **** 						bvar = (BUFFER_SIZE-1);  // maximum post trigger buffer size
 1138              		.loc 1 508 0
 1139 07ee 40F2FF33 		movw	r3, #1023
 1140 07f2 FB83     		strh	r3, [r7, #30]	@ movhi
 1141 07f4 04E0     		b	.L62
 1142              	.L61:
 509:main.c        **** 					}
 510:main.c        **** 					else if(bvar <= 2)
 1143              		.loc 1 510 0
 1144 07f6 FB8B     		ldrh	r3, [r7, #30]
 1145 07f8 022B     		cmp	r3, #2
 1146 07fa 01D8     		bhi	.L62
 511:main.c        **** 					{
 512:main.c        **** 						bvar = 2; // minimum post trigger buffer size
 1147              		.loc 1 512 0
 1148 07fc 0223     		movs	r3, #2
 1149 07fe FB83     		strh	r3, [r7, #30]	@ movhi
 1150              	.L62:
 513:main.c        **** 					}
 514:main.c        **** 					
 515:main.c        **** 					// update the period to match the trigger buffer size post trigger capture
 516:main.c        **** 					PWM_Sample_Buffer_WritePeriod(bvar); // post trigger buffer
 1151              		.loc 1 516 0
 1152 0800 FB8B     		ldrh	r3, [r7, #30]
 1153 0802 1846     		mov	r0, r3
 1154 0804 FFF7FEFF 		bl	PWM_Sample_Buffer_WritePeriod
 517:main.c        **** 					// after setting the period, need to set the count to the proper value as well
 518:main.c        **** 					PWM_Sample_Buffer_WriteCounter(bvar); // post trigger buffer					
 1155              		.loc 1 518 0
 1156 0808 FB8B     		ldrh	r3, [r7, #30]
 1157 080a 1846     		mov	r0, r3
 1158 080c FFF7FEFF 		bl	PWM_Sample_Buffer_WriteCounter
 1159 0810 AEE2     		b	.L4
 1160              	.L124:
 1161 0812 00BFAFF3 		.align	3
 1161      0080
 1162              	.L123:
 1163 0818 524CFEFF 		.word	-111534
 1164 081c 83D7B73F 		.word	1069012867
 1165 0820 EF384547 		.word	1195718895
 1166 0824 72790A40 		.word	1074428274
 1167 0828 6631B1F9 		.word	-105827994
 1168 082c B836E83F 		.word	1072182968
 1169 0830 00000000 		.word	.LC0
 1170 0834 20000000 		.word	.LC2
 1171 0838 40540948 		.word	1208570944
 1172 083c 00000000 		.word	trigger_source
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 31


 1173 0840 00000000 		.word	preamp_a
 1174 0844 00000000 		.word	preamp_trig
 1175 0848 00000000 		.word	preamp_b
 1176 084c 00007F43 		.word	1132396544
 1177              	.L60:
 519:main.c        **** 				}
 520:main.c        **** 				else if(*psz == 'R')
 1178              		.loc 1 520 0
 1179 0850 FB68     		ldr	r3, [r7, #12]
 1180 0852 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1181 0854 522B     		cmp	r3, #82
 1182 0856 40F0F180 		bne	.L63
 521:main.c        **** 				{
 522:main.c        **** 					// Scope control register update
 523:main.c        **** 					// data comes back as an ascii number, representing an 8 bit value
 524:main.c        **** 					// bit 7: unused
 525:main.c        **** 					// bit 6: Internal (0, a or b as defined later) or External Trigger (1)
 526:main.c        **** 					// bit 5: trigger polarity, rising (0) or falling (1)
 527:main.c        **** 					// bit 4: trigger source, A (0) or B (1)
 528:main.c        **** 					// bits 3:0 -> sample rate 20 Msps / (2^thisval) this val can be 0 - 15
 529:main.c        **** 					psz = strtok(0, " ");
 1183              		.loc 1 529 0
 1184 085a 0020     		movs	r0, #0
 1185 085c B749     		ldr	r1, .L125
 1186 085e FFF7FEFF 		bl	strtok
 1187 0862 F860     		str	r0, [r7, #12]
 530:main.c        **** 					sscanf(psz,"%hu", &avar);
 1188              		.loc 1 530 0
 1189 0864 BB1C     		adds	r3, r7, #2
 1190 0866 F868     		ldr	r0, [r7, #12]
 1191 0868 B549     		ldr	r1, .L125+4
 1192 086a 1A46     		mov	r2, r3
 1193 086c FFF7FEFF 		bl	sscanf
 531:main.c        **** 					
 532:main.c        **** 					// internal versus external trigger
 533:main.c        **** 					// bit 6
 534:main.c        **** 					if((avar & 0x40) == 0)
 1194              		.loc 1 534 0
 1195 0870 7B88     		ldrh	r3, [r7, #2]
 1196 0872 03F04003 		and	r3, r3, #64
 1197 0876 002B     		cmp	r3, #0
 1198 0878 2AD1     		bne	.L64
 535:main.c        **** 					{
 536:main.c        **** 						// internal trigger
 537:main.c        **** 						// trigger polarity
 538:main.c        **** 						// bit 5
 539:main.c        **** 						if((avar & 0x20) == 0)
 1199              		.loc 1 539 0
 1200 087a 7B88     		ldrh	r3, [r7, #2]
 1201 087c 03F02003 		and	r3, r3, #32
 1202 0880 002B     		cmp	r3, #0
 1203 0882 12D1     		bne	.L65
 540:main.c        **** 						{
 541:main.c        **** 							// rising edge
 542:main.c        **** 							Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_MASK);
 1204              		.loc 1 542 0
 1205 0884 FFF7FEFF 		bl	Trigger_Control_Read
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 32


 1206 0888 0346     		mov	r3, r0
 1207 088a 23F00F03 		bic	r3, r3, #15
 1208 088e DBB2     		uxtb	r3, r3
 1209 0890 1846     		mov	r0, r3
 1210 0892 FFF7FEFF 		bl	Trigger_Control_Write
 543:main.c        ****     						Trigger_Control_Write(Trigger_Control_Read() | RISING_EDGE_TRIGGERED);
 1211              		.loc 1 543 0
 1212 0896 FFF7FEFF 		bl	Trigger_Control_Read
 1213 089a 0346     		mov	r3, r0
 1214 089c 43F00203 		orr	r3, r3, #2
 1215 08a0 DBB2     		uxtb	r3, r3
 1216 08a2 1846     		mov	r0, r3
 1217 08a4 FFF7FEFF 		bl	Trigger_Control_Write
 1218 08a8 24E0     		b	.L67
 1219              	.L65:
 544:main.c        **** 						}
 545:main.c        **** 						else
 546:main.c        **** 						{
 547:main.c        **** 							// falling edge
 548:main.c        **** 							Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_MASK);
 1220              		.loc 1 548 0
 1221 08aa FFF7FEFF 		bl	Trigger_Control_Read
 1222 08ae 0346     		mov	r3, r0
 1223 08b0 23F00F03 		bic	r3, r3, #15
 1224 08b4 DBB2     		uxtb	r3, r3
 1225 08b6 1846     		mov	r0, r3
 1226 08b8 FFF7FEFF 		bl	Trigger_Control_Write
 549:main.c        ****     						Trigger_Control_Write(Trigger_Control_Read() | FALLING_EDGE_TRIGGERED);
 1227              		.loc 1 549 0
 1228 08bc FFF7FEFF 		bl	Trigger_Control_Read
 1229 08c0 0346     		mov	r3, r0
 1230 08c2 43F00103 		orr	r3, r3, #1
 1231 08c6 DBB2     		uxtb	r3, r3
 1232 08c8 1846     		mov	r0, r3
 1233 08ca FFF7FEFF 		bl	Trigger_Control_Write
 1234 08ce 11E0     		b	.L67
 1235              	.L64:
 550:main.c        **** 						}
 551:main.c        **** 					}
 552:main.c        **** 					else
 553:main.c        **** 					{
 554:main.c        **** 						// external trigger
 555:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_MASK);
 1236              		.loc 1 555 0
 1237 08d0 FFF7FEFF 		bl	Trigger_Control_Read
 1238 08d4 0346     		mov	r3, r0
 1239 08d6 23F00F03 		bic	r3, r3, #15
 1240 08da DBB2     		uxtb	r3, r3
 1241 08dc 1846     		mov	r0, r3
 1242 08de FFF7FEFF 		bl	Trigger_Control_Write
 556:main.c        ****     					Trigger_Control_Write(Trigger_Control_Read() | EXTERNAL_TRIGGERED);
 1243              		.loc 1 556 0
 1244 08e2 FFF7FEFF 		bl	Trigger_Control_Read
 1245 08e6 0346     		mov	r3, r0
 1246 08e8 43F00803 		orr	r3, r3, #8
 1247 08ec DBB2     		uxtb	r3, r3
 1248 08ee 1846     		mov	r0, r3
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 33


 1249 08f0 FFF7FEFF 		bl	Trigger_Control_Write
 1250              	.L67:
 557:main.c        **** 					}
 558:main.c        **** 					
 559:main.c        **** 					// bit 4
 560:main.c        **** 					// trigger source select
 561:main.c        **** 					if((avar & 0x10) == 0)
 1251              		.loc 1 561 0
 1252 08f4 7B88     		ldrh	r3, [r7, #2]
 1253 08f6 03F01003 		and	r3, r3, #16
 1254 08fa 002B     		cmp	r3, #0
 1255 08fc 06D1     		bne	.L68
 562:main.c        **** 					{
 563:main.c        **** 						// channel 1 / A
 564:main.c        **** 						trigger_source = SCOPE_CHANNEL_1;
 1256              		.loc 1 564 0
 1257 08fe 914B     		ldr	r3, .L125+8
 1258 0900 0022     		movs	r2, #0
 1259 0902 1A70     		strb	r2, [r3]
 565:main.c        **** 						Amux_Trigger_Select(SCOPE_CHANNEL_1);
 1260              		.loc 1 565 0
 1261 0904 0020     		movs	r0, #0
 1262 0906 FFF7FEFF 		bl	Amux_Trigger_FastSelect
 1263 090a 05E0     		b	.L69
 1264              	.L68:
 566:main.c        **** 					}
 567:main.c        **** 					else
 568:main.c        **** 					{
 569:main.c        **** 						// channel 2 / B
 570:main.c        **** 						trigger_source = SCOPE_CHANNEL_2;
 1265              		.loc 1 570 0
 1266 090c 8D4B     		ldr	r3, .L125+8
 1267 090e 0122     		movs	r2, #1
 1268 0910 1A70     		strb	r2, [r3]
 571:main.c        **** 						Amux_Trigger_Select(SCOPE_CHANNEL_2);
 1269              		.loc 1 571 0
 1270 0912 0120     		movs	r0, #1
 1271 0914 FFF7FEFF 		bl	Amux_Trigger_FastSelect
 1272              	.L69:
 572:main.c        **** 					}
 573:main.c        **** 					
 574:main.c        **** 					// sample rate
 575:main.c        **** 					// bit 3:0
 576:main.c        **** 					if((avar & 0x0f) <= 0) // 818.2 Ksps "maximum" sample rate
 1273              		.loc 1 576 0
 1274 0918 7B88     		ldrh	r3, [r7, #2]
 1275 091a 03F00F03 		and	r3, r3, #15
 1276 091e 002B     		cmp	r3, #0
 1277 0920 04DC     		bgt	.L70
 577:main.c        **** 					{
 578:main.c        ****                         // 36 Mhz master clock divided by this number and then divided by 
 579:main.c        ****                         // 18 due to the freq divider set the ADC sample rate.
 580:main.c        **** 						SampleClock_SetDividerValue(1); 
 1278              		.loc 1 580 0
 1279 0922 0020     		movs	r0, #0
 1280 0924 0121     		movs	r1, #1
 1281 0926 FFF7FEFF 		bl	SampleClock_SetDividerRegister
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 34


 1282 092a 21E2     		b	.L4
 1283              	.L70:
 581:main.c        **** 					}
 582:main.c        **** 					else if((avar & 0x0f) == 1) // 409.1 ksps
 1284              		.loc 1 582 0
 1285 092c 7B88     		ldrh	r3, [r7, #2]
 1286 092e 03F00F03 		and	r3, r3, #15
 1287 0932 012B     		cmp	r3, #1
 1288 0934 04D1     		bne	.L72
 583:main.c        **** 					{
 584:main.c        **** 						SampleClock_SetDividerValue(2);
 1289              		.loc 1 584 0
 1290 0936 0120     		movs	r0, #1
 1291 0938 0121     		movs	r1, #1
 1292 093a FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1293 093e 17E2     		b	.L4
 1294              	.L72:
 585:main.c        **** 					}
 586:main.c        **** 					else if((avar & 0x0f) == 2) // 204.5 ksps
 1295              		.loc 1 586 0
 1296 0940 7B88     		ldrh	r3, [r7, #2]
 1297 0942 03F00F03 		and	r3, r3, #15
 1298 0946 022B     		cmp	r3, #2
 1299 0948 04D1     		bne	.L73
 587:main.c        **** 					{
 588:main.c        **** 						SampleClock_SetDividerValue(4);
 1300              		.loc 1 588 0
 1301 094a 0320     		movs	r0, #3
 1302 094c 0121     		movs	r1, #1
 1303 094e FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1304 0952 0DE2     		b	.L4
 1305              	.L73:
 589:main.c        **** 					}
 590:main.c        **** 					else if((avar & 0x0f) == 3) // 102.3 ksps
 1306              		.loc 1 590 0
 1307 0954 7B88     		ldrh	r3, [r7, #2]
 1308 0956 03F00F03 		and	r3, r3, #15
 1309 095a 032B     		cmp	r3, #3
 1310 095c 04D1     		bne	.L74
 591:main.c        **** 					{
 592:main.c        **** 						SampleClock_SetDividerValue(8);
 1311              		.loc 1 592 0
 1312 095e 0720     		movs	r0, #7
 1313 0960 0121     		movs	r1, #1
 1314 0962 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1315 0966 03E2     		b	.L4
 1316              	.L74:
 593:main.c        **** 					}
 594:main.c        **** 					else if((avar & 0x0f) == 4) // 51.1 ksps
 1317              		.loc 1 594 0
 1318 0968 7B88     		ldrh	r3, [r7, #2]
 1319 096a 03F00F03 		and	r3, r3, #15
 1320 096e 042B     		cmp	r3, #4
 1321 0970 04D1     		bne	.L75
 595:main.c        **** 					{ 
 596:main.c        **** 						SampleClock_SetDividerValue(16);
 1322              		.loc 1 596 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 35


 1323 0972 0F20     		movs	r0, #15
 1324 0974 0121     		movs	r1, #1
 1325 0976 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1326 097a F9E1     		b	.L4
 1327              	.L75:
 597:main.c        **** 					}
 598:main.c        **** 					else if((avar & 0x0f) == 5) // 25.6 ksps
 1328              		.loc 1 598 0
 1329 097c 7B88     		ldrh	r3, [r7, #2]
 1330 097e 03F00F03 		and	r3, r3, #15
 1331 0982 052B     		cmp	r3, #5
 1332 0984 04D1     		bne	.L76
 599:main.c        **** 					{
 600:main.c        **** 						SampleClock_SetDividerValue(32);
 1333              		.loc 1 600 0
 1334 0986 1F20     		movs	r0, #31
 1335 0988 0121     		movs	r1, #1
 1336 098a FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1337 098e EFE1     		b	.L4
 1338              	.L76:
 601:main.c        **** 					}
 602:main.c        **** 					else if((avar & 0x0f) == 6) // 12.8 ksps
 1339              		.loc 1 602 0
 1340 0990 7B88     		ldrh	r3, [r7, #2]
 1341 0992 03F00F03 		and	r3, r3, #15
 1342 0996 062B     		cmp	r3, #6
 1343 0998 04D1     		bne	.L77
 603:main.c        **** 					{
 604:main.c        **** 						SampleClock_SetDividerValue(64);
 1344              		.loc 1 604 0
 1345 099a 3F20     		movs	r0, #63
 1346 099c 0121     		movs	r1, #1
 1347 099e FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1348 09a2 E5E1     		b	.L4
 1349              	.L77:
 605:main.c        **** 					}
 606:main.c        **** 					else if((avar & 0x0f) == 7) // 6.4 ksps
 1350              		.loc 1 606 0
 1351 09a4 7B88     		ldrh	r3, [r7, #2]
 1352 09a6 03F00F03 		and	r3, r3, #15
 1353 09aa 072B     		cmp	r3, #7
 1354 09ac 04D1     		bne	.L78
 607:main.c        **** 					{ 
 608:main.c        **** 						SampleClock_SetDividerValue(128);
 1355              		.loc 1 608 0
 1356 09ae 7F20     		movs	r0, #127
 1357 09b0 0121     		movs	r1, #1
 1358 09b2 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1359 09b6 DBE1     		b	.L4
 1360              	.L78:
 609:main.c        **** 					}
 610:main.c        **** 					else if((avar & 0x0f) == 8) // 3.2 ksps
 1361              		.loc 1 610 0
 1362 09b8 7B88     		ldrh	r3, [r7, #2]
 1363 09ba 03F00F03 		and	r3, r3, #15
 1364 09be 082B     		cmp	r3, #8
 1365 09c0 04D1     		bne	.L79
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 36


 611:main.c        **** 					{
 612:main.c        **** 						SampleClock_SetDividerValue(256);
 1366              		.loc 1 612 0
 1367 09c2 FF20     		movs	r0, #255
 1368 09c4 0121     		movs	r1, #1
 1369 09c6 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1370 09ca D1E1     		b	.L4
 1371              	.L79:
 613:main.c        **** 					}
 614:main.c        **** 					else if((avar & 0x0f) == 9) // 1.6 ksps
 1372              		.loc 1 614 0
 1373 09cc 7B88     		ldrh	r3, [r7, #2]
 1374 09ce 03F00F03 		and	r3, r3, #15
 1375 09d2 092B     		cmp	r3, #9
 1376 09d4 05D1     		bne	.L80
 615:main.c        **** 					{
 616:main.c        **** 						SampleClock_SetDividerValue(512);
 1377              		.loc 1 616 0
 1378 09d6 40F2FF10 		movw	r0, #511
 1379 09da 0121     		movs	r1, #1
 1380 09dc FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1381 09e0 C6E1     		b	.L4
 1382              	.L80:
 617:main.c        **** 					}
 618:main.c        **** 					else if((avar & 0x0f) == 10) // 799 sps 
 1383              		.loc 1 618 0
 1384 09e2 7B88     		ldrh	r3, [r7, #2]
 1385 09e4 03F00F03 		and	r3, r3, #15
 1386 09e8 0A2B     		cmp	r3, #10
 1387 09ea 05D1     		bne	.L81
 619:main.c        **** 					{ 
 620:main.c        **** 						SampleClock_SetDividerValue(1024);
 1388              		.loc 1 620 0
 1389 09ec 40F2FF30 		movw	r0, #1023
 1390 09f0 0121     		movs	r1, #1
 1391 09f2 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1392 09f6 BBE1     		b	.L4
 1393              	.L81:
 621:main.c        **** 					}
 622:main.c        **** 					else if((avar & 0x0f) == 11) // 400 sps
 1394              		.loc 1 622 0
 1395 09f8 7B88     		ldrh	r3, [r7, #2]
 1396 09fa 03F00F03 		and	r3, r3, #15
 1397 09fe 0B2B     		cmp	r3, #11
 1398 0a00 05D1     		bne	.L82
 623:main.c        **** 					{ 
 624:main.c        **** 						SampleClock_SetDividerValue(2048);
 1399              		.loc 1 624 0
 1400 0a02 40F2FF70 		movw	r0, #2047
 1401 0a06 0121     		movs	r1, #1
 1402 0a08 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1403 0a0c B0E1     		b	.L4
 1404              	.L82:
 625:main.c        **** 					}                    
 626:main.c        **** 					else if((avar & 0x0f) == 12) // 200 sps
 1405              		.loc 1 626 0
 1406 0a0e 7B88     		ldrh	r3, [r7, #2]
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 37


 1407 0a10 03F00F03 		and	r3, r3, #15
 1408 0a14 0C2B     		cmp	r3, #12
 1409 0a16 05D1     		bne	.L83
 627:main.c        **** 					{ 
 628:main.c        **** 						SampleClock_SetDividerValue(4096);
 1410              		.loc 1 628 0
 1411 0a18 40F6FF70 		movw	r0, #4095
 1412 0a1c 0121     		movs	r1, #1
 1413 0a1e FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1414 0a22 A5E1     		b	.L4
 1415              	.L83:
 629:main.c        **** 					}
 630:main.c        **** 					else if((avar & 0x0f) >= 13) // 100 sps
 1416              		.loc 1 630 0
 1417 0a24 7B88     		ldrh	r3, [r7, #2]
 1418 0a26 03F00F03 		and	r3, r3, #15
 1419 0a2a 0C2B     		cmp	r3, #12
 1420 0a2c 40F3A081 		ble	.L4
 631:main.c        **** 					{ 
 632:main.c        **** 						SampleClock_SetDividerValue(8192);
 1421              		.loc 1 632 0
 1422 0a30 41F6FF70 		movw	r0, #8191
 1423 0a34 0121     		movs	r1, #1
 1424 0a36 FFF7FEFF 		bl	SampleClock_SetDividerRegister
 1425 0a3a 99E1     		b	.L4
 1426              	.L63:
 633:main.c        **** 					}
 634:main.c        ****                 }
 635:main.c        **** 				else if(*psz == 'D')
 1427              		.loc 1 635 0
 1428 0a3c FB68     		ldr	r3, [r7, #12]
 1429 0a3e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1430 0a40 442B     		cmp	r3, #68
 1431 0a42 59D1     		bne	.L84
 636:main.c        **** 				{
 637:main.c        **** 					// Scope debug hardware command
 638:main.c        **** 					// data comes back as an ascii number, representing a single value
 639:main.c        **** 					// 0 set reset to 0
 640:main.c        **** 					// 1 set reset to 1
 641:main.c        **** 					// 2 set REQ = 0
 642:main.c        **** 					// 3 set REQ = 1
 643:main.c        **** 					// 4 set MAN_TRIG = 1
 644:main.c        **** 					// 5 set MAN_TRIG = 0
 645:main.c        **** 					psz = strtok(0, " ");
 1432              		.loc 1 645 0
 1433 0a44 0020     		movs	r0, #0
 1434 0a46 3D49     		ldr	r1, .L125
 1435 0a48 FFF7FEFF 		bl	strtok
 1436 0a4c F860     		str	r0, [r7, #12]
 646:main.c        **** 					sscanf(psz,"%hu", &avar);
 1437              		.loc 1 646 0
 1438 0a4e BB1C     		adds	r3, r7, #2
 1439 0a50 F868     		ldr	r0, [r7, #12]
 1440 0a52 3B49     		ldr	r1, .L125+4
 1441 0a54 1A46     		mov	r2, r3
 1442 0a56 FFF7FEFF 		bl	sscanf
 647:main.c        **** 					
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 38


 648:main.c        **** 					if(avar == 0) // reset PWM = 0
 1443              		.loc 1 648 0
 1444 0a5a 7B88     		ldrh	r3, [r7, #2]
 1445 0a5c 002B     		cmp	r3, #0
 1446 0a5e 09D1     		bne	.L85
 649:main.c        **** 					{
 650:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() & ~RESET_PWM);
 1447              		.loc 1 650 0
 1448 0a60 FFF7FEFF 		bl	Trigger_Control_Read
 1449 0a64 0346     		mov	r3, r0
 1450 0a66 03F07F03 		and	r3, r3, #127
 1451 0a6a DBB2     		uxtb	r3, r3
 1452 0a6c 1846     		mov	r0, r3
 1453 0a6e FFF7FEFF 		bl	Trigger_Control_Write
 1454 0a72 7DE1     		b	.L4
 1455              	.L85:
 651:main.c        **** 					}
 652:main.c        **** 					else if(avar == 1) // reset PWM = 1
 1456              		.loc 1 652 0
 1457 0a74 7B88     		ldrh	r3, [r7, #2]
 1458 0a76 012B     		cmp	r3, #1
 1459 0a78 09D1     		bne	.L87
 653:main.c        **** 					{
 654:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() | RESET_PWM);
 1460              		.loc 1 654 0
 1461 0a7a FFF7FEFF 		bl	Trigger_Control_Read
 1462 0a7e 0346     		mov	r3, r0
 1463 0a80 63F07F03 		orn	r3, r3, #127
 1464 0a84 DBB2     		uxtb	r3, r3
 1465 0a86 1846     		mov	r0, r3
 1466 0a88 FFF7FEFF 		bl	Trigger_Control_Write
 1467 0a8c 70E1     		b	.L4
 1468              	.L87:
 655:main.c        **** 					}
 656:main.c        **** 					else if(avar == 2) // set REQ = 0
 1469              		.loc 1 656 0
 1470 0a8e 7B88     		ldrh	r3, [r7, #2]
 1471 0a90 022B     		cmp	r3, #2
 1472 0a92 09D1     		bne	.L88
 657:main.c        **** 					{
 658:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_ARM);
 1473              		.loc 1 658 0
 1474 0a94 FFF7FEFF 		bl	Trigger_Control_Read
 1475 0a98 0346     		mov	r3, r0
 1476 0a9a 23F04003 		bic	r3, r3, #64
 1477 0a9e DBB2     		uxtb	r3, r3
 1478 0aa0 1846     		mov	r0, r3
 1479 0aa2 FFF7FEFF 		bl	Trigger_Control_Write
 1480 0aa6 63E1     		b	.L4
 1481              	.L88:
 659:main.c        **** 					}
 660:main.c        **** 					else if(avar == 3) // set REQ = 1
 1482              		.loc 1 660 0
 1483 0aa8 7B88     		ldrh	r3, [r7, #2]
 1484 0aaa 032B     		cmp	r3, #3
 1485 0aac 09D1     		bne	.L89
 661:main.c        **** 					{
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 39


 662:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() | TRIGGER_ARM);
 1486              		.loc 1 662 0
 1487 0aae FFF7FEFF 		bl	Trigger_Control_Read
 1488 0ab2 0346     		mov	r3, r0
 1489 0ab4 43F04003 		orr	r3, r3, #64
 1490 0ab8 DBB2     		uxtb	r3, r3
 1491 0aba 1846     		mov	r0, r3
 1492 0abc FFF7FEFF 		bl	Trigger_Control_Write
 1493 0ac0 56E1     		b	.L4
 1494              	.L89:
 663:main.c        **** 					}
 664:main.c        **** 					else if(avar == 4) // manual trigger = 0
 1495              		.loc 1 664 0
 1496 0ac2 7B88     		ldrh	r3, [r7, #2]
 1497 0ac4 042B     		cmp	r3, #4
 1498 0ac6 09D1     		bne	.L90
 665:main.c        **** 					{
 666:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() & ~MANUAL_TRIGGER);
 1499              		.loc 1 666 0
 1500 0ac8 FFF7FEFF 		bl	Trigger_Control_Read
 1501 0acc 0346     		mov	r3, r0
 1502 0ace 23F01003 		bic	r3, r3, #16
 1503 0ad2 DBB2     		uxtb	r3, r3
 1504 0ad4 1846     		mov	r0, r3
 1505 0ad6 FFF7FEFF 		bl	Trigger_Control_Write
 1506 0ada 49E1     		b	.L4
 1507              	.L90:
 667:main.c        **** 					}
 668:main.c        **** 					else if(avar == 5) // manual trigger = 1
 1508              		.loc 1 668 0
 1509 0adc 7B88     		ldrh	r3, [r7, #2]
 1510 0ade 052B     		cmp	r3, #5
 1511 0ae0 40F04681 		bne	.L4
 669:main.c        **** 					{
 670:main.c        **** 						//Trigger_Control_Write(Trigger_Control_Read() | TRIGGER_ARM);
 671:main.c        **** 						//Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_ARM);
 672:main.c        **** 						Trigger_Control_Write(Trigger_Control_Read() | MANUAL_TRIGGER);
 1512              		.loc 1 672 0
 1513 0ae4 FFF7FEFF 		bl	Trigger_Control_Read
 1514 0ae8 0346     		mov	r3, r0
 1515 0aea 43F01003 		orr	r3, r3, #16
 1516 0aee DBB2     		uxtb	r3, r3
 1517 0af0 1846     		mov	r0, r3
 1518 0af2 FFF7FEFF 		bl	Trigger_Control_Write
 1519 0af6 3BE1     		b	.L4
 1520              	.L84:
 673:main.c        **** 					}
 674:main.c        **** 					
 675:main.c        **** 				}
 676:main.c        **** 				else if(*psz == 'G')
 1521              		.loc 1 676 0
 1522 0af8 FB68     		ldr	r3, [r7, #12]
 1523 0afa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1524 0afc 472B     		cmp	r3, #71
 1525 0afe 12D1     		bne	.L91
 677:main.c        **** 				{
 678:main.c        **** 					// Scope GO, arms the scope and waits for a trigger event
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 40


 679:main.c        **** 					// if a trigger occurs, sends back the character 'A' followed
 680:main.c        **** 					// by a 2nd and 3rd byte in binary format indicating the address
 681:main.c        **** 					// where the capture ended in the buffer (10 bits).  I'm assuming Aa format
 682:main.c        **** 					
 683:main.c        **** 					// arm the scope
 684:main.c        **** 					Trigger_Control_Write(Trigger_Control_Read() | TRIGGER_ARM);
 1526              		.loc 1 684 0
 1527 0b00 FFF7FEFF 		bl	Trigger_Control_Read
 1528 0b04 0346     		mov	r3, r0
 1529 0b06 43F04003 		orr	r3, r3, #64
 1530 0b0a DBB2     		uxtb	r3, r3
 1531 0b0c 1846     		mov	r0, r3
 1532 0b0e FFF7FEFF 		bl	Trigger_Control_Write
 685:main.c        **** 					Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_ARM);
 1533              		.loc 1 685 0
 1534 0b12 FFF7FEFF 		bl	Trigger_Control_Read
 1535 0b16 0346     		mov	r3, r0
 1536 0b18 23F04003 		bic	r3, r3, #64
 1537 0b1c DBB2     		uxtb	r3, r3
 1538 0b1e 1846     		mov	r0, r3
 1539 0b20 FFF7FEFF 		bl	Trigger_Control_Write
 1540 0b24 24E1     		b	.L4
 1541              	.L91:
 686:main.c        **** 					
 687:main.c        **** 				}
 688:main.c        **** 				else if(*psz == 'B')
 1542              		.loc 1 688 0
 1543 0b26 FB68     		ldr	r3, [r7, #12]
 1544 0b28 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1545 0b2a 422B     		cmp	r3, #66
 1546 0b2c 40F0F080 		bne	.L92
 689:main.c        **** 				{
 690:main.c        **** 					// dump the scope buffer
 691:main.c        **** 					PutChar('D');
 1547              		.loc 1 691 0
 1548 0b30 4420     		movs	r0, #68
 1549 0b32 FFF7FEFF 		bl	PutChar
 692:main.c        **** 					
 693:main.c        **** 					for(i = 0; i < BUFFER_SIZE; i++)
 1550              		.loc 1 693 0
 1551 0b36 0023     		movs	r3, #0
 1552 0b38 BB83     		strh	r3, [r7, #28]	@ movhi
 1553 0b3a E3E0     		b	.L93
 1554              	.L126:
 1555              		.align	2
 1556              	.L125:
 1557 0b3c 00000000 		.word	.LC0
 1558 0b40 20000000 		.word	.LC2
 1559 0b44 00000000 		.word	trigger_source
 1560              	.L103:
 694:main.c        **** 					{
 695:main.c        **** 						// truncate to 10 bits and "offset" to work with scope hardware
 696:main.c        **** 						if(preamp_a == 1)
 1561              		.loc 1 696 0
 1562 0b48 B34B     		ldr	r3, .L127+32
 1563 0b4a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1564 0b4c 012B     		cmp	r3, #1
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 41


 1565 0b4e 20D1     		bne	.L94
 697:main.c        **** 						{ // preamp gain of 1
 698:main.c        **** 							avar = (uint16) (511 - (Channel_1_Data[i]/42.68));
 1566              		.loc 1 698 0
 1567 0b50 BB8B     		ldrh	r3, [r7, #28]
 1568 0b52 B24A     		ldr	r2, .L127+36
 1569 0b54 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 1570 0b58 1846     		mov	r0, r3
 1571 0b5a FFF7FEFF 		bl	__aeabi_i2d
 1572 0b5e 0246     		mov	r2, r0
 1573 0b60 0B46     		mov	r3, r1
 1574 0b62 1046     		mov	r0, r2
 1575 0b64 1946     		mov	r1, r3
 1576 0b66 A4A3     		adr	r3, .L127
 1577 0b68 D3E90023 		ldrd	r2, [r3]
 1578 0b6c FFF7FEFF 		bl	__aeabi_ddiv
 1579 0b70 0246     		mov	r2, r0
 1580 0b72 0B46     		mov	r3, r1
 1581 0b74 A2A1     		adr	r1, .L127+8
 1582 0b76 D1E90001 		ldrd	r0, [r1]
 1583 0b7a FFF7FEFF 		bl	__aeabi_dsub
 1584 0b7e 0246     		mov	r2, r0
 1585 0b80 0B46     		mov	r3, r1
 1586 0b82 1046     		mov	r0, r2
 1587 0b84 1946     		mov	r1, r3
 1588 0b86 FFF7FEFF 		bl	__aeabi_d2uiz
 1589 0b8a 0346     		mov	r3, r0
 1590 0b8c 9BB2     		uxth	r3, r3
 1591 0b8e 7B80     		strh	r3, [r7, #2]	@ movhi
 1592 0b90 1FE0     		b	.L95
 1593              	.L94:
 699:main.c        **** 						}
 700:main.c        **** 						else
 701:main.c        **** 						{ // preamp gain of 10
 702:main.c        **** 							// GJL - fix truncation at 3V by changing 511 to 1023 and fixing in scope.tcl also
 703:main.c        ****                             avar = (uint16) (1023 - (Channel_1_Data[i]/4.8497));
 1594              		.loc 1 703 0
 1595 0b92 BB8B     		ldrh	r3, [r7, #28]
 1596 0b94 A14A     		ldr	r2, .L127+36
 1597 0b96 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 1598 0b9a 1846     		mov	r0, r3
 1599 0b9c FFF7FEFF 		bl	__aeabi_i2d
 1600 0ba0 0246     		mov	r2, r0
 1601 0ba2 0B46     		mov	r3, r1
 1602 0ba4 1046     		mov	r0, r2
 1603 0ba6 1946     		mov	r1, r3
 1604 0ba8 97A3     		adr	r3, .L127+16
 1605 0baa D3E90023 		ldrd	r2, [r3]
 1606 0bae FFF7FEFF 		bl	__aeabi_ddiv
 1607 0bb2 0246     		mov	r2, r0
 1608 0bb4 0B46     		mov	r3, r1
 1609 0bb6 96A1     		adr	r1, .L127+24
 1610 0bb8 D1E90001 		ldrd	r0, [r1]
 1611 0bbc FFF7FEFF 		bl	__aeabi_dsub
 1612 0bc0 0246     		mov	r2, r0
 1613 0bc2 0B46     		mov	r3, r1
 1614 0bc4 1046     		mov	r0, r2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 42


 1615 0bc6 1946     		mov	r1, r3
 1616 0bc8 FFF7FEFF 		bl	__aeabi_d2uiz
 1617 0bcc 0346     		mov	r3, r0
 1618 0bce 9BB2     		uxth	r3, r3
 1619 0bd0 7B80     		strh	r3, [r7, #2]	@ movhi
 1620              	.L95:
 704:main.c        **** 						}
 705:main.c        **** 						
 706:main.c        **** 						if(preamp_b == 1)
 1621              		.loc 1 706 0
 1622 0bd2 934B     		ldr	r3, .L127+40
 1623 0bd4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1624 0bd6 012B     		cmp	r3, #1
 1625 0bd8 1FD1     		bne	.L96
 707:main.c        **** 						{ // preamp gain of 1
 708:main.c        **** 							bvar = (uint16) (511 - (Channel_2_Data[i]/42.68));
 1626              		.loc 1 708 0
 1627 0bda BB8B     		ldrh	r3, [r7, #28]
 1628 0bdc 914A     		ldr	r2, .L127+44
 1629 0bde 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 1630 0be2 1846     		mov	r0, r3
 1631 0be4 FFF7FEFF 		bl	__aeabi_i2d
 1632 0be8 0246     		mov	r2, r0
 1633 0bea 0B46     		mov	r3, r1
 1634 0bec 1046     		mov	r0, r2
 1635 0bee 1946     		mov	r1, r3
 1636 0bf0 81A3     		adr	r3, .L127
 1637 0bf2 D3E90023 		ldrd	r2, [r3]
 1638 0bf6 FFF7FEFF 		bl	__aeabi_ddiv
 1639 0bfa 0246     		mov	r2, r0
 1640 0bfc 0B46     		mov	r3, r1
 1641 0bfe 80A1     		adr	r1, .L127+8
 1642 0c00 D1E90001 		ldrd	r0, [r1]
 1643 0c04 FFF7FEFF 		bl	__aeabi_dsub
 1644 0c08 0246     		mov	r2, r0
 1645 0c0a 0B46     		mov	r3, r1
 1646 0c0c 1046     		mov	r0, r2
 1647 0c0e 1946     		mov	r1, r3
 1648 0c10 FFF7FEFF 		bl	__aeabi_d2uiz
 1649 0c14 0346     		mov	r3, r0
 1650 0c16 FB83     		strh	r3, [r7, #30]	@ movhi
 1651 0c18 1EE0     		b	.L97
 1652              	.L96:
 709:main.c        **** 						}
 710:main.c        **** 						else
 711:main.c        **** 						{ // preamp gain of 10
 712:main.c        **** 							bvar = (uint16) (1023 - (Channel_2_Data[i]/4.8497));
 1653              		.loc 1 712 0
 1654 0c1a BB8B     		ldrh	r3, [r7, #28]
 1655 0c1c 814A     		ldr	r2, .L127+44
 1656 0c1e 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 1657 0c22 1846     		mov	r0, r3
 1658 0c24 FFF7FEFF 		bl	__aeabi_i2d
 1659 0c28 0246     		mov	r2, r0
 1660 0c2a 0B46     		mov	r3, r1
 1661 0c2c 1046     		mov	r0, r2
 1662 0c2e 1946     		mov	r1, r3
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 43


 1663 0c30 75A3     		adr	r3, .L127+16
 1664 0c32 D3E90023 		ldrd	r2, [r3]
 1665 0c36 FFF7FEFF 		bl	__aeabi_ddiv
 1666 0c3a 0246     		mov	r2, r0
 1667 0c3c 0B46     		mov	r3, r1
 1668 0c3e 74A1     		adr	r1, .L127+24
 1669 0c40 D1E90001 		ldrd	r0, [r1]
 1670 0c44 FFF7FEFF 		bl	__aeabi_dsub
 1671 0c48 0246     		mov	r2, r0
 1672 0c4a 0B46     		mov	r3, r1
 1673 0c4c 1046     		mov	r0, r2
 1674 0c4e 1946     		mov	r1, r3
 1675 0c50 FFF7FEFF 		bl	__aeabi_d2uiz
 1676 0c54 0346     		mov	r3, r0
 1677 0c56 FB83     		strh	r3, [r7, #30]	@ movhi
 1678              	.L97:
 713:main.c        **** 						}
 714:main.c        **** 						
 715:main.c        **** 						// send the data out to the terminal
 716:main.c        **** 						USB_Out_Buffer[(i*4+0) % USBUART_BUFFER_SIZE] = (uint8) ((avar >> 8) & 0x0003); // address of
 1679              		.loc 1 716 0
 1680 0c58 BB8B     		ldrh	r3, [r7, #28]
 1681 0c5a 9B00     		lsls	r3, r3, #2
 1682 0c5c 03F03C03 		and	r3, r3, #60
 1683 0c60 7A88     		ldrh	r2, [r7, #2]
 1684 0c62 120A     		lsrs	r2, r2, #8
 1685 0c64 92B2     		uxth	r2, r2
 1686 0c66 D2B2     		uxtb	r2, r2
 1687 0c68 02F00302 		and	r2, r2, #3
 1688 0c6c D1B2     		uxtb	r1, r2
 1689 0c6e 6E4A     		ldr	r2, .L127+48
 1690 0c70 D154     		strb	r1, [r2, r3]
 717:main.c        **** 						USB_Out_Buffer[(i*4+1) % USBUART_BUFFER_SIZE] = (uint8) (avar & 0x00FF); // address of the en
 1691              		.loc 1 717 0
 1692 0c72 BB8B     		ldrh	r3, [r7, #28]
 1693 0c74 9B00     		lsls	r3, r3, #2
 1694 0c76 5A1C     		adds	r2, r3, #1
 1695 0c78 6C4B     		ldr	r3, .L127+52
 1696 0c7a 1340     		ands	r3, r3, r2
 1697 0c7c 002B     		cmp	r3, #0
 1698 0c7e 03DA     		bge	.L98
 1699 0c80 013B     		subs	r3, r3, #1
 1700 0c82 63F03F03 		orn	r3, r3, #63
 1701 0c86 0133     		adds	r3, r3, #1
 1702              	.L98:
 1703 0c88 1A46     		mov	r2, r3
 1704 0c8a 7B88     		ldrh	r3, [r7, #2]
 1705 0c8c D9B2     		uxtb	r1, r3
 1706 0c8e 664B     		ldr	r3, .L127+48
 1707 0c90 9954     		strb	r1, [r3, r2]
 718:main.c        **** 						USB_Out_Buffer[(i*4+2) % USBUART_BUFFER_SIZE] = (uint8) ((bvar >> 8) & 0x0003); // address of
 1708              		.loc 1 718 0
 1709 0c92 BB8B     		ldrh	r3, [r7, #28]
 1710 0c94 9B00     		lsls	r3, r3, #2
 1711 0c96 9A1C     		adds	r2, r3, #2
 1712 0c98 644B     		ldr	r3, .L127+52
 1713 0c9a 1340     		ands	r3, r3, r2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 44


 1714 0c9c 002B     		cmp	r3, #0
 1715 0c9e 03DA     		bge	.L99
 1716 0ca0 013B     		subs	r3, r3, #1
 1717 0ca2 63F03F03 		orn	r3, r3, #63
 1718 0ca6 0133     		adds	r3, r3, #1
 1719              	.L99:
 1720 0ca8 1A46     		mov	r2, r3
 1721 0caa FB8B     		ldrh	r3, [r7, #30]
 1722 0cac 1B0A     		lsrs	r3, r3, #8
 1723 0cae 9BB2     		uxth	r3, r3
 1724 0cb0 DBB2     		uxtb	r3, r3
 1725 0cb2 03F00303 		and	r3, r3, #3
 1726 0cb6 D9B2     		uxtb	r1, r3
 1727 0cb8 5B4B     		ldr	r3, .L127+48
 1728 0cba 9954     		strb	r1, [r3, r2]
 719:main.c        **** 						USB_Out_Buffer[(i*4+3) % USBUART_BUFFER_SIZE] = (uint8) (bvar & 0x00FF); // address of the en
 1729              		.loc 1 719 0
 1730 0cbc BB8B     		ldrh	r3, [r7, #28]
 1731 0cbe 9B00     		lsls	r3, r3, #2
 1732 0cc0 DA1C     		adds	r2, r3, #3
 1733 0cc2 5A4B     		ldr	r3, .L127+52
 1734 0cc4 1340     		ands	r3, r3, r2
 1735 0cc6 002B     		cmp	r3, #0
 1736 0cc8 03DA     		bge	.L100
 1737 0cca 013B     		subs	r3, r3, #1
 1738 0ccc 63F03F03 		orn	r3, r3, #63
 1739 0cd0 0133     		adds	r3, r3, #1
 1740              	.L100:
 1741 0cd2 1A46     		mov	r2, r3
 1742 0cd4 FB8B     		ldrh	r3, [r7, #30]	@ movhi
 1743 0cd6 D9B2     		uxtb	r1, r3
 1744 0cd8 534B     		ldr	r3, .L127+48
 1745 0cda 9954     		strb	r1, [r3, r2]
 720:main.c        **** 						
 721:main.c        **** 						// our buffer has been filled up, dump the data out the serial port
 722:main.c        **** 						if(((i*4+4) % USBUART_BUFFER_SIZE) == 0)
 1746              		.loc 1 722 0
 1747 0cdc BB8B     		ldrh	r3, [r7, #28]
 1748 0cde 0133     		adds	r3, r3, #1
 1749 0ce0 9B00     		lsls	r3, r3, #2
 1750 0ce2 03F03C03 		and	r3, r3, #60
 1751 0ce6 002B     		cmp	r3, #0
 1752 0ce8 09D1     		bne	.L101
 723:main.c        **** 						{
 724:main.c        **** 							while(USBUART_CDCIsReady() == 0){};
 1753              		.loc 1 724 0
 1754 0cea 00BF     		nop
 1755              	.L102:
 1756              		.loc 1 724 0 is_stmt 0 discriminator 1
 1757 0cec FFF7FEFF 		bl	USBUART_CDCIsReady
 1758 0cf0 0346     		mov	r3, r0
 1759 0cf2 002B     		cmp	r3, #0
 1760 0cf4 FAD0     		beq	.L102
 725:main.c        **** 							USBUART_PutData(USB_Out_Buffer, USBUART_BUFFER_SIZE);
 1761              		.loc 1 725 0 is_stmt 1
 1762 0cf6 4C48     		ldr	r0, .L127+48
 1763 0cf8 4021     		movs	r1, #64
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 45


 1764 0cfa FFF7FEFF 		bl	USBUART_PutData
 1765              	.L101:
 693:main.c        **** 					{
 1766              		.loc 1 693 0 discriminator 2
 1767 0cfe BB8B     		ldrh	r3, [r7, #28]
 1768 0d00 0133     		adds	r3, r3, #1
 1769 0d02 BB83     		strh	r3, [r7, #28]	@ movhi
 1770              	.L93:
 693:main.c        **** 					{
 1771              		.loc 1 693 0 is_stmt 0 discriminator 1
 1772 0d04 BB8B     		ldrh	r3, [r7, #28]
 1773 0d06 B3F5806F 		cmp	r3, #1024
 1774 0d0a FFF41DAF 		bcc	.L103
 1775 0d0e 2FE0     		b	.L4
 1776              	.L92:
 726:main.c        **** 						}
 727:main.c        **** 					}
 728:main.c        **** 				}
 729:main.c        **** 				else if(*psz == 'P')
 1777              		.loc 1 729 0 is_stmt 1
 1778 0d10 FB68     		ldr	r3, [r7, #12]
 1779 0d12 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1780 0d14 502B     		cmp	r3, #80
 1781 0d16 24D1     		bne	.L104
 730:main.c        **** 				{
 731:main.c        **** 					// Scope Preamp settings
 732:main.c        **** 					// a = channel 1 preamp 10x
 733:main.c        **** 					// A = channel 1 preamp 1x
 734:main.c        **** 					// b = channel 2 preamp 10x
 735:main.c        **** 					// B = channel 2 preamp 1x
 736:main.c        **** 					psz = strtok(0, " ");
 1782              		.loc 1 736 0
 1783 0d18 0020     		movs	r0, #0
 1784 0d1a 4549     		ldr	r1, .L127+56
 1785 0d1c FFF7FEFF 		bl	strtok
 1786 0d20 F860     		str	r0, [r7, #12]
 737:main.c        **** 					
 738:main.c        **** 					if(*psz == 'a')
 1787              		.loc 1 738 0
 1788 0d22 FB68     		ldr	r3, [r7, #12]
 1789 0d24 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1790 0d26 612B     		cmp	r3, #97
 1791 0d28 03D1     		bne	.L105
 739:main.c        **** 					{
 740:main.c        **** 						preamp_a = 10;
 1792              		.loc 1 740 0
 1793 0d2a 3B4B     		ldr	r3, .L127+32
 1794 0d2c 0A22     		movs	r2, #10
 1795 0d2e 1A70     		strb	r2, [r3]
 1796 0d30 1EE0     		b	.L4
 1797              	.L105:
 741:main.c        **** 					}
 742:main.c        **** 					else if(*psz == 'A')
 1798              		.loc 1 742 0
 1799 0d32 FB68     		ldr	r3, [r7, #12]
 1800 0d34 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1801 0d36 412B     		cmp	r3, #65
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 46


 1802 0d38 03D1     		bne	.L107
 743:main.c        **** 					{
 744:main.c        **** 						preamp_a = 1;
 1803              		.loc 1 744 0
 1804 0d3a 374B     		ldr	r3, .L127+32
 1805 0d3c 0122     		movs	r2, #1
 1806 0d3e 1A70     		strb	r2, [r3]
 1807 0d40 16E0     		b	.L4
 1808              	.L107:
 745:main.c        **** 					}
 746:main.c        **** 					else if(*psz == 'b')
 1809              		.loc 1 746 0
 1810 0d42 FB68     		ldr	r3, [r7, #12]
 1811 0d44 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1812 0d46 622B     		cmp	r3, #98
 1813 0d48 03D1     		bne	.L108
 747:main.c        **** 					{
 748:main.c        **** 						preamp_b = 10;
 1814              		.loc 1 748 0
 1815 0d4a 354B     		ldr	r3, .L127+40
 1816 0d4c 0A22     		movs	r2, #10
 1817 0d4e 1A70     		strb	r2, [r3]
 1818 0d50 0EE0     		b	.L4
 1819              	.L108:
 749:main.c        **** 					}
 750:main.c        **** 					else if(*psz == 'B')
 1820              		.loc 1 750 0
 1821 0d52 FB68     		ldr	r3, [r7, #12]
 1822 0d54 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1823 0d56 422B     		cmp	r3, #66
 1824 0d58 0AD1     		bne	.L4
 751:main.c        **** 					{
 752:main.c        **** 						preamp_b = 1;
 1825              		.loc 1 752 0
 1826 0d5a 314B     		ldr	r3, .L127+40
 1827 0d5c 0122     		movs	r2, #1
 1828 0d5e 1A70     		strb	r2, [r3]
 1829 0d60 06E0     		b	.L4
 1830              	.L104:
 753:main.c        **** 					}
 754:main.c        **** 					
 755:main.c        **** 				}
 756:main.c        **** 				else
 757:main.c        **** 				{
 758:main.c        **** 					PutString("Error: Unrecognized Scope Command\n\r");
 1831              		.loc 1 758 0
 1832 0d62 3448     		ldr	r0, .L127+60
 1833 0d64 FFF7FEFF 		bl	PutString
 1834 0d68 02E0     		b	.L4
 1835              	.L48:
 759:main.c        **** 				}
 760:main.c        **** 			// END OF SCOPE 'S' COMMANDS
 761:main.c        **** 			}
 762:main.c        **** 			else
 763:main.c        **** 			{
 764:main.c        **** 				// command not recognized, toss it
 765:main.c        **** 				PutString("Error: Unknown Command\n\r");
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 47


 1836              		.loc 1 765 0
 1837 0d6a 3348     		ldr	r0, .L127+64
 1838 0d6c FFF7FEFF 		bl	PutString
 1839              	.L4:
 766:main.c        **** 			}
 767:main.c        **** 			bCommandReady = 0;
 1840              		.loc 1 767 0
 1841 0d70 324B     		ldr	r3, .L127+68
 1842 0d72 0022     		movs	r2, #0
 1843 0d74 1A70     		strb	r2, [r3]
 1844              	.L2:
 768:main.c        **** 		}
 769:main.c        **** 		
 770:main.c        **** 		status = Trigger_Status_Read();
 1845              		.loc 1 770 0
 1846 0d76 FFF7FEFF 		bl	Trigger_Status_Read
 1847 0d7a 0346     		mov	r3, r0
 1848 0d7c FB71     		strb	r3, [r7, #7]
 771:main.c        **** 						
 772:main.c        **** 		// if we have completed a capture, get the index of the last sample
 773:main.c        **** 		if((status & CAPTURE_COMPLETE ) != 0)
 1849              		.loc 1 773 0
 1850 0d7e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1851 0d80 03F00403 		and	r3, r3, #4
 1852 0d84 002B     		cmp	r3, #0
 1853 0d86 18D0     		beq	.L109
 774:main.c        **** 		{
 775:main.c        **** 			ending_offset = GetLastSampleIndex(DMA_Channel_1_Chan);
 1854              		.loc 1 775 0
 1855 0d88 2D4B     		ldr	r3, .L127+72
 1856 0d8a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1857 0d8c 1846     		mov	r0, r3
 1858 0d8e FFF7FEFF 		bl	GetLastSampleIndex
 1859 0d92 0346     		mov	r3, r0
 1860 0d94 BB80     		strh	r3, [r7, #4]	@ movhi
 776:main.c        **** 			
 777:main.c        **** 			// return the capture info
 778:main.c        **** 			PutChar('A');
 1861              		.loc 1 778 0
 1862 0d96 4120     		movs	r0, #65
 1863 0d98 FFF7FEFF 		bl	PutChar
 779:main.c        **** 			PutChar((uint8) ((ending_offset >> 8) & 0x0003)); // address of the end, MSbits
 1864              		.loc 1 779 0
 1865 0d9c BB88     		ldrh	r3, [r7, #4]
 1866 0d9e 1B0A     		lsrs	r3, r3, #8
 1867 0da0 9BB2     		uxth	r3, r3
 1868 0da2 DBB2     		uxtb	r3, r3
 1869 0da4 03F00303 		and	r3, r3, #3
 1870 0da8 DBB2     		uxtb	r3, r3
 1871 0daa 1846     		mov	r0, r3
 1872 0dac FFF7FEFF 		bl	PutChar
 780:main.c        **** 			PutChar((uint8) (ending_offset & 0x00FF)); // address of the end, LSbits
 1873              		.loc 1 780 0
 1874 0db0 BB88     		ldrh	r3, [r7, #4]	@ movhi
 1875 0db2 DBB2     		uxtb	r3, r3
 1876 0db4 1846     		mov	r0, r3
 1877 0db6 FFF7FEFF 		bl	PutChar
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 48


 1878              	.L109:
 781:main.c        **** 			//PutChar('\n'); // terminate the return data, through testing, there is no need to send this ch
 782:main.c        **** 		}
 783:main.c        **** 	
 784:main.c        **** 		// digital input update
 785:main.c        **** 		if((Digital_Input_Status_Last != Digital_Input_Status_Read()) && (Digital_AutoUpdate != 0))
 1879              		.loc 1 785 0
 1880 0dba FFF7FEFF 		bl	Digital_Input_Status_Read
 1881 0dbe 0346     		mov	r3, r0
 1882 0dc0 1A46     		mov	r2, r3
 1883 0dc2 204B     		ldr	r3, .L127+76
 1884 0dc4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1885 0dc6 9A42     		cmp	r2, r3
 1886 0dc8 12D0     		beq	.L110
 1887              		.loc 1 785 0 is_stmt 0 discriminator 1
 1888 0dca 1F4B     		ldr	r3, .L127+80
 1889 0dcc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1890 0dce 002B     		cmp	r3, #0
 1891 0dd0 0ED0     		beq	.L110
 786:main.c        **** 		{
 787:main.c        **** 			PutChar('I');
 1892              		.loc 1 787 0 is_stmt 1
 1893 0dd2 4920     		movs	r0, #73
 1894 0dd4 FFF7FEFF 		bl	PutChar
 788:main.c        **** 			PutChar((uint8) Digital_Input_Status_Read());
 1895              		.loc 1 788 0
 1896 0dd8 FFF7FEFF 		bl	Digital_Input_Status_Read
 1897 0ddc 0346     		mov	r3, r0
 1898 0dde 1846     		mov	r0, r3
 1899 0de0 FFF7FEFF 		bl	PutChar
 789:main.c        **** 			Digital_Input_Status_Last = Digital_Input_Status_Read();
 1900              		.loc 1 789 0
 1901 0de4 FFF7FEFF 		bl	Digital_Input_Status_Read
 1902 0de8 0346     		mov	r3, r0
 1903 0dea 1A46     		mov	r2, r3
 1904 0dec 154B     		ldr	r3, .L127+76
 1905 0dee 1A70     		strb	r2, [r3]
 1906              	.L110:
 790:main.c        **** 		}
 791:main.c        **** 	}
 1907              		.loc 1 791 0
 1908 0df0 FFF70DB9 		b	.L111
 1909              	.L128:
 1910 0df4 AFF30080 		.align	3
 1911              	.L127:
 1912 0df8 D7A3703D 		.word	1030792151
 1913 0dfc 0A574540 		.word	1078286090
 1914 0e00 00000000 		.word	0
 1915 0e04 00F07F40 		.word	1082126336
 1916 0e08 12A5BDC1 		.word	-1044536046
 1917 0e0c 17661340 		.word	1075013143
 1918 0e10 00000000 		.word	0
 1919 0e14 00F88F40 		.word	1083176960
 1920 0e18 00000000 		.word	preamp_a
 1921 0e1c 00000000 		.word	Channel_1_Data
 1922 0e20 00000000 		.word	preamp_b
 1923 0e24 00000000 		.word	Channel_2_Data
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 49


 1924 0e28 00000000 		.word	USB_Out_Buffer
 1925 0e2c 3F000080 		.word	-2147483585
 1926 0e30 00000000 		.word	.LC0
 1927 0e34 24000000 		.word	.LC3
 1928 0e38 48000000 		.word	.LC4
 1929 0e3c 00000000 		.word	bCommandReady
 1930 0e40 00000000 		.word	DMA_Channel_1_Chan
 1931 0e44 00000000 		.word	Digital_Input_Status_Last
 1932 0e48 00000000 		.word	Digital_AutoUpdate
 1933              		.cfi_endproc
 1934              	.LFE63:
 1935              		.size	main, .-main
 1936 0e4c AFF30080 		.section	.text.Hardware_Config,"ax",%progbits
 1937              		.align	2
 1938              		.global	Hardware_Config
 1939              		.thumb
 1940              		.thumb_func
 1941              		.type	Hardware_Config, %function
 1942              	Hardware_Config:
 1943              	.LFB64:
 792:main.c        **** }
 793:main.c        **** 
 794:main.c        **** void Hardware_Config(void)
 795:main.c        **** {
 1944              		.loc 1 795 0
 1945              		.cfi_startproc
 1946              		@ args = 0, pretend = 0, frame = 0
 1947              		@ frame_needed = 1, uses_anonymous_args = 0
 1948 0000 80B5     		push	{r7, lr}
 1949              		.cfi_def_cfa_offset 8
 1950              		.cfi_offset 7, -8
 1951              		.cfi_offset 14, -4
 1952 0002 00AF     		add	r7, sp, #0
 1953              		.cfi_def_cfa_register 7
 796:main.c        ****     CyGlobalIntEnable;
 1954              		.loc 1 796 0
 1955              	@ 796 "main.c" 1
 1956 0004 62B6     		CPSIE   i
 1957              	@ 0 "" 2
 797:main.c        **** 	
 798:main.c        **** 	cCommandsReady = 0;
 1958              		.loc 1 798 0
 1959              		.thumb
 1960 0006 384B     		ldr	r3, .L131
 1961 0008 0022     		movs	r2, #0
 1962 000a 1A80     		strh	r2, [r3]	@ movhi
 799:main.c        **** 	bCommandReady = 0;
 1963              		.loc 1 799 0
 1964 000c 374B     		ldr	r3, .L131+4
 1965 000e 0022     		movs	r2, #0
 1966 0010 1A70     		strb	r2, [r3]
 800:main.c        ****     
 801:main.c        ****     USBUART_Start(0, USBUART_5V_OPERATION);
 1967              		.loc 1 801 0
 1968 0012 0020     		movs	r0, #0
 1969 0014 0121     		movs	r1, #1
 1970 0016 FFF7FEFF 		bl	USBUART_Start
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 50


 802:main.c        **** 	while(!USBUART_GetConfiguration())
 1971              		.loc 1 802 0
 1972 001a 00BF     		nop
 1973              	.L130:
 1974              		.loc 1 802 0 is_stmt 0 discriminator 1
 1975 001c FFF7FEFF 		bl	USBUART_GetConfiguration
 1976 0020 0346     		mov	r3, r0
 1977 0022 002B     		cmp	r3, #0
 1978 0024 FAD0     		beq	.L130
 803:main.c        ****     {
 804:main.c        ****         /* Wait for USBUART to complete configuration */
 805:main.c        ****     }
 806:main.c        ****     USBUART_CDC_Init();
 1979              		.loc 1 806 0 is_stmt 1
 1980 0026 FFF7FEFF 		bl	USBUART_CDC_Init
 807:main.c        **** 	
 808:main.c        **** 	Amux_Trigger_Select(SCOPE_CHANNEL_1);
 1981              		.loc 1 808 0
 1982 002a 0020     		movs	r0, #0
 1983 002c FFF7FEFF 		bl	Amux_Trigger_FastSelect
 809:main.c        ****     
 810:main.c        ****     ADC_1_Start();
 1984              		.loc 1 810 0
 1985 0030 FFF7FEFF 		bl	ADC_1_Start
 811:main.c        ****     ADC_2_Start();
 1986              		.loc 1 811 0
 1987 0034 FFF7FEFF 		bl	ADC_2_Start
 812:main.c        ****     
 813:main.c        ****     Vtrigger_Start();
 1988              		.loc 1 813 0
 1989 0038 FFF7FEFF 		bl	Vtrigger_Start
 814:main.c        ****     Trigger_Comp_Start();
 1990              		.loc 1 814 0
 1991 003c FFF7FEFF 		bl	Trigger_Comp_Start
 815:main.c        ****     
 816:main.c        ****     // The extras
 817:main.c        ****     Trig_Buf_Start();
 1992              		.loc 1 817 0
 1993 0040 FFF7FEFF 		bl	Trig_Buf_Start
 818:main.c        ****     
 819:main.c        ****     PWM_Sample_Buffer_Start();
 1994              		.loc 1 819 0
 1995 0044 FFF7FEFF 		bl	PWM_Sample_Buffer_Start
 820:main.c        **** 	// update the period to match the trigger buffer size for maximum post trigger capture
 821:main.c        **** 	PWM_Sample_Buffer_WritePeriod(BUFFER_SIZE-1); // maximum post trigger buffer
 1996              		.loc 1 821 0
 1997 0048 40F2FF30 		movw	r0, #1023
 1998 004c FFF7FEFF 		bl	PWM_Sample_Buffer_WritePeriod
 822:main.c        **** 	//PWM_Sample_Buffer_WritePeriod(2); // minimum post trigger buffer, 3 samples after trigger (used 
 823:main.c        **** 	// after setting the period, need to set the count to the proper value as well
 824:main.c        **** 	PWM_Sample_Buffer_WriteCounter(BUFFER_SIZE-1); // maximum post trigger buffer
 1999              		.loc 1 824 0
 2000 0050 40F2FF30 		movw	r0, #1023
 2001 0054 FFF7FEFF 		bl	PWM_Sample_Buffer_WriteCounter
 825:main.c        **** 	//PWM_Sample_Buffer_WriteCounter(2); // minimum post trigger buffer, 3 samples after trigger
 826:main.c        **** 	
 827:main.c        **** 	preamp_a = 1;
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 51


 2002              		.loc 1 827 0
 2003 0058 254B     		ldr	r3, .L131+8
 2004 005a 0122     		movs	r2, #1
 2005 005c 1A70     		strb	r2, [r3]
 828:main.c        **** 	preamp_b = 1;
 2006              		.loc 1 828 0
 2007 005e 254B     		ldr	r3, .L131+12
 2008 0060 0122     		movs	r2, #1
 2009 0062 1A70     		strb	r2, [r3]
 829:main.c        **** 	trigger_source = SCOPE_CHANNEL_1;
 2010              		.loc 1 829 0
 2011 0064 244B     		ldr	r3, .L131+16
 2012 0066 0022     		movs	r2, #0
 2013 0068 1A70     		strb	r2, [r3]
 830:main.c        ****     
 831:main.c        **** 	// basic configuration is trigger on the rising edge of channel 0
 832:main.c        **** 	Trigger_Control_Write(Trigger_Control_Read() & ~TRIGGER_MASK);
 2014              		.loc 1 832 0
 2015 006a FFF7FEFF 		bl	Trigger_Control_Read
 2016 006e 0346     		mov	r3, r0
 2017 0070 23F00F03 		bic	r3, r3, #15
 2018 0074 DBB2     		uxtb	r3, r3
 2019 0076 1846     		mov	r0, r3
 2020 0078 FFF7FEFF 		bl	Trigger_Control_Write
 833:main.c        ****     Trigger_Control_Write(Trigger_Control_Read() | RISING_EDGE_TRIGGERED);
 2021              		.loc 1 833 0
 2022 007c FFF7FEFF 		bl	Trigger_Control_Read
 2023 0080 0346     		mov	r3, r0
 2024 0082 43F00203 		orr	r3, r3, #2
 2025 0086 DBB2     		uxtb	r3, r3
 2026 0088 1846     		mov	r0, r3
 2027 008a FFF7FEFF 		bl	Trigger_Control_Write
 834:main.c        ****     //Trigger_Control_Write(Trigger_Control_Read() | FALLING_EDGE_TRIGGERED);
 835:main.c        ****     //Trigger_Control_Write(Trigger_Control_Read() | EITHER_EDGE_TRIGGERED);
 836:main.c        ****     //Trigger_Control_Write(Trigger_Control_Read() | EXTERNAL_TRIGGERED);
 837:main.c        **** 	
 838:main.c        **** 	// waveform generator control
 839:main.c        **** 	Wave_Control_Write(Wave_Control_Read() & ~WAVE_SELECT_MASK);
 2028              		.loc 1 839 0
 2029 008e FFF7FEFF 		bl	Wave_Control_Read
 2030 0092 0346     		mov	r3, r0
 2031 0094 23F00103 		bic	r3, r3, #1
 2032 0098 DBB2     		uxtb	r3, r3
 2033 009a 1846     		mov	r0, r3
 2034 009c FFF7FEFF 		bl	Wave_Control_Write
 840:main.c        **** 	Wave_Control_Write(Wave_Control_Read() | WAVE_SELECT_WAVE);
 2035              		.loc 1 840 0
 2036 00a0 FFF7FEFF 		bl	Wave_Control_Read
 2037 00a4 0346     		mov	r3, r0
 2038 00a6 1846     		mov	r0, r3
 2039 00a8 FFF7FEFF 		bl	Wave_Control_Write
 841:main.c        **** 	// Wave_Control_Write(Wave_Control_Read() | WAVE_SELECT_NOISE);
 842:main.c        **** 	Wave_DAC_Start();
 2040              		.loc 1 842 0
 2041 00ac FFF7FEFF 		bl	Wave_DAC_Start
 843:main.c        **** 	Wave_Buf_Start();
 2042              		.loc 1 843 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 52


 2043 00b0 FFF7FEFF 		bl	Wave_Buf_Start
 844:main.c        **** 	Wave_DAC_Wave1Setup(&Waveform_Buffer[0], WAVEFORM_BUFFER_SIZE);
 2044              		.loc 1 844 0
 2045 00b4 1148     		ldr	r0, .L131+20
 2046 00b6 4FF48071 		mov	r1, #256
 2047 00ba FFF7FEFF 		bl	Wave_DAC_Wave1Setup
 845:main.c        **** 	wave_gain = 0;
 2048              		.loc 1 845 0
 2049 00be 104B     		ldr	r3, .L131+24
 2050 00c0 0022     		movs	r2, #0
 2051 00c2 1A70     		strb	r2, [r3]
 846:main.c        **** 	
 847:main.c        **** 	PRS_Start();
 2052              		.loc 1 847 0
 2053 00c4 FFF7FEFF 		bl	PRS_Start
 848:main.c        **** 	Wave_DAC_Wave2Setup((uint8 *) PRS_SEED_PTR, 1);
 2054              		.loc 1 848 0
 2055 00c8 0E48     		ldr	r0, .L131+28
 2056 00ca 0121     		movs	r1, #1
 2057 00cc FFF7FEFF 		bl	Wave_DAC_Wave2Setup
 849:main.c        **** 	
 850:main.c        **** 	// digital IO initializations
 851:main.c        **** 	Digital_Input_Status_Last = 0;
 2058              		.loc 1 851 0
 2059 00d0 0D4B     		ldr	r3, .L131+32
 2060 00d2 0022     		movs	r2, #0
 2061 00d4 1A70     		strb	r2, [r3]
 852:main.c        **** 	Digital_Out_Control_Write(0);
 2062              		.loc 1 852 0
 2063 00d6 0020     		movs	r0, #0
 2064 00d8 FFF7FEFF 		bl	Digital_Out_Control_Write
 853:main.c        **** 	Digital_AutoUpdate = 0;
 2065              		.loc 1 853 0
 2066 00dc 0B4B     		ldr	r3, .L131+36
 2067 00de 0022     		movs	r2, #0
 2068 00e0 1A70     		strb	r2, [r3]
 854:main.c        **** 	
 855:main.c        **** 	Digital_PWM_Start();
 2069              		.loc 1 855 0
 2070 00e2 FFF7FEFF 		bl	Digital_PWM_Start
 856:main.c        **** }
 2071              		.loc 1 856 0
 2072 00e6 80BD     		pop	{r7, pc}
 2073              	.L132:
 2074              		.align	2
 2075              	.L131:
 2076 00e8 00000000 		.word	cCommandsReady
 2077 00ec 00000000 		.word	bCommandReady
 2078 00f0 00000000 		.word	preamp_a
 2079 00f4 00000000 		.word	preamp_b
 2080 00f8 00000000 		.word	trigger_source
 2081 00fc 00000000 		.word	Waveform_Buffer
 2082 0100 00000000 		.word	wave_gain
 2083 0104 04640040 		.word	1073767428
 2084 0108 00000000 		.word	Digital_Input_Status_Last
 2085 010c 00000000 		.word	Digital_AutoUpdate
 2086              		.cfi_endproc
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 53


 2087              	.LFE64:
 2088              		.size	Hardware_Config, .-Hardware_Config
 2089              		.section	.text.DMA_Config,"ax",%progbits
 2090              		.align	2
 2091              		.global	DMA_Config
 2092              		.thumb
 2093              		.thumb_func
 2094              		.type	DMA_Config, %function
 2095              	DMA_Config:
 2096              	.LFB65:
 857:main.c        **** 
 858:main.c        **** void DMA_Config(void)
 859:main.c        **** {
 2097              		.loc 1 859 0
 2098              		.cfi_startproc
 2099              		@ args = 0, pretend = 0, frame = 0
 2100              		@ frame_needed = 1, uses_anonymous_args = 0
 2101 0000 80B5     		push	{r7, lr}
 2102              		.cfi_def_cfa_offset 8
 2103              		.cfi_offset 7, -8
 2104              		.cfi_offset 14, -4
 2105 0002 00AF     		add	r7, sp, #0
 2106              		.cfi_def_cfa_register 7
 860:main.c        ****     DMA_Channel_1_Chan = DMA_Channel_1_DmaInitialize(DMA_Channel_1_BYTES_PER_BURST, DMA_Channel_1_R
 2107              		.loc 1 860 0
 2108 0004 0220     		movs	r0, #2
 2109 0006 0121     		movs	r1, #1
 2110 0008 4FF48042 		mov	r2, #16384
 2111 000c 41F6FF73 		movw	r3, #8191
 2112 0010 FFF7FEFF 		bl	DMA_Channel_1_DmaInitialize
 2113 0014 0346     		mov	r3, r0
 2114 0016 1A46     		mov	r2, r3
 2115 0018 424B     		ldr	r3, .L135
 2116 001a 1A70     		strb	r2, [r3]
 861:main.c        ****         HI16(DMA_Channel_1_SRC_BASE), HI16(DMA_Channel_1_DST_BASE));
 862:main.c        ****     DMA_Channel_1_TD[0] = CyDmaTdAllocate();
 2117              		.loc 1 862 0
 2118 001c FFF7FEFF 		bl	CyDmaTdAllocate
 2119 0020 0346     		mov	r3, r0
 2120 0022 1A46     		mov	r2, r3
 2121 0024 404B     		ldr	r3, .L135+4
 2122 0026 1A70     		strb	r2, [r3]
 863:main.c        ****     CyDmaTdSetConfiguration(DMA_Channel_1_TD[0], BUFFER_SIZE*sizeof(int16), DMA_Channel_1_TD[0], DM
 2123              		.loc 1 863 0
 2124 0028 3F4B     		ldr	r3, .L135+4
 2125 002a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2126 002c 3E4B     		ldr	r3, .L135+4
 2127 002e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2128 0030 1046     		mov	r0, r2
 2129 0032 4FF40061 		mov	r1, #2048
 2130 0036 1A46     		mov	r2, r3
 2131 0038 0623     		movs	r3, #6
 2132 003a FFF7FEFF 		bl	CyDmaTdSetConfiguration
 864:main.c        ****     CyDmaTdSetAddress(DMA_Channel_1_TD[0], LO16((uint32)ADC_1_SAR_WRK0_PTR), LO16((uint32)&Channel_
 2133              		.loc 1 864 0
 2134 003e 3A4B     		ldr	r3, .L135+4
 2135 0040 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 54


 2136 0042 3A4B     		ldr	r3, .L135+8
 2137 0044 9BB2     		uxth	r3, r3
 2138 0046 1046     		mov	r0, r2
 2139 0048 45F6A031 		movw	r1, #23456
 2140 004c 1A46     		mov	r2, r3
 2141 004e FFF7FEFF 		bl	CyDmaTdSetAddress
 865:main.c        ****     CyDmaChSetInitialTd(DMA_Channel_1_Chan, DMA_Channel_1_TD[0]);
 2142              		.loc 1 865 0
 2143 0052 344B     		ldr	r3, .L135
 2144 0054 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2145 0056 344B     		ldr	r3, .L135+4
 2146 0058 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2147 005a 1046     		mov	r0, r2
 2148 005c 1946     		mov	r1, r3
 2149 005e FFF7FEFF 		bl	CyDmaChSetInitialTd
 866:main.c        ****     CyDmaChRoundRobin(DMA_Channel_1_Chan, 1);
 2150              		.loc 1 866 0
 2151 0062 304B     		ldr	r3, .L135
 2152 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2153 0066 1846     		mov	r0, r3
 2154 0068 0121     		movs	r1, #1
 2155 006a FFF7FEFF 		bl	CyDmaChRoundRobin
 867:main.c        ****     CyDmaChSetRequest(DMA_Channel_1_Chan, CPU_TERM_CHAIN);
 2156              		.loc 1 867 0
 2157 006e 2D4B     		ldr	r3, .L135
 2158 0070 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2159 0072 1846     		mov	r0, r3
 2160 0074 0421     		movs	r1, #4
 2161 0076 FFF7FEFF 		bl	CyDmaChSetRequest
 868:main.c        ****     CyDmaChEnable(DMA_Channel_1_Chan, 1);
 2162              		.loc 1 868 0
 2163 007a 2A4B     		ldr	r3, .L135
 2164 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2165 007e 1846     		mov	r0, r3
 2166 0080 0121     		movs	r1, #1
 2167 0082 FFF7FEFF 		bl	CyDmaChEnable
 869:main.c        ****     CyDmaChEnable(DMA_Channel_1_Chan, 1);
 2168              		.loc 1 869 0
 2169 0086 274B     		ldr	r3, .L135
 2170 0088 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2171 008a 1846     		mov	r0, r3
 2172 008c 0121     		movs	r1, #1
 2173 008e FFF7FEFF 		bl	CyDmaChEnable
 870:main.c        **** 
 871:main.c        ****     DMA_Channel_2_Chan = DMA_Channel_2_DmaInitialize(DMA_Channel_2_BYTES_PER_BURST, DMA_Channel_2_R
 2174              		.loc 1 871 0
 2175 0092 0220     		movs	r0, #2
 2176 0094 0121     		movs	r1, #1
 2177 0096 4FF48042 		mov	r2, #16384
 2178 009a 41F6FF73 		movw	r3, #8191
 2179 009e FFF7FEFF 		bl	DMA_Channel_2_DmaInitialize
 2180 00a2 0346     		mov	r3, r0
 2181 00a4 1A46     		mov	r2, r3
 2182 00a6 224B     		ldr	r3, .L135+12
 2183 00a8 1A70     		strb	r2, [r3]
 872:main.c        ****         HI16(DMA_Channel_2_SRC_BASE), HI16(DMA_Channel_2_DST_BASE));
 873:main.c        ****     DMA_Channel_2_TD[0] = CyDmaTdAllocate();
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 55


 2184              		.loc 1 873 0
 2185 00aa FFF7FEFF 		bl	CyDmaTdAllocate
 2186 00ae 0346     		mov	r3, r0
 2187 00b0 1A46     		mov	r2, r3
 2188 00b2 204B     		ldr	r3, .L135+16
 2189 00b4 1A70     		strb	r2, [r3]
 874:main.c        ****     CyDmaTdSetConfiguration(DMA_Channel_2_TD[0], BUFFER_SIZE*sizeof(int16), DMA_Channel_2_TD[0], DM
 2190              		.loc 1 874 0
 2191 00b6 1F4B     		ldr	r3, .L135+16
 2192 00b8 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2193 00ba 1E4B     		ldr	r3, .L135+16
 2194 00bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2195 00be 1046     		mov	r0, r2
 2196 00c0 4FF40061 		mov	r1, #2048
 2197 00c4 1A46     		mov	r2, r3
 2198 00c6 0223     		movs	r3, #2
 2199 00c8 FFF7FEFF 		bl	CyDmaTdSetConfiguration
 875:main.c        ****     CyDmaTdSetAddress(DMA_Channel_2_TD[0], LO16((uint32)ADC_2_SAR_WRK0_PTR), LO16((uint32)&Channel_
 2200              		.loc 1 875 0
 2201 00cc 194B     		ldr	r3, .L135+16
 2202 00ce 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2203 00d0 194B     		ldr	r3, .L135+20
 2204 00d2 9BB2     		uxth	r3, r3
 2205 00d4 1046     		mov	r0, r2
 2206 00d6 45F6A231 		movw	r1, #23458
 2207 00da 1A46     		mov	r2, r3
 2208 00dc FFF7FEFF 		bl	CyDmaTdSetAddress
 876:main.c        ****     CyDmaChSetInitialTd(DMA_Channel_2_Chan, DMA_Channel_2_TD[0]);
 2209              		.loc 1 876 0
 2210 00e0 134B     		ldr	r3, .L135+12
 2211 00e2 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2212 00e4 134B     		ldr	r3, .L135+16
 2213 00e6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2214 00e8 1046     		mov	r0, r2
 2215 00ea 1946     		mov	r1, r3
 2216 00ec FFF7FEFF 		bl	CyDmaChSetInitialTd
 877:main.c        ****     CyDmaChRoundRobin(DMA_Channel_2_Chan, 1);
 2217              		.loc 1 877 0
 2218 00f0 0F4B     		ldr	r3, .L135+12
 2219 00f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2220 00f4 1846     		mov	r0, r3
 2221 00f6 0121     		movs	r1, #1
 2222 00f8 FFF7FEFF 		bl	CyDmaChRoundRobin
 878:main.c        ****     CyDmaChSetRequest(DMA_Channel_2_Chan, CPU_TERM_CHAIN);
 2223              		.loc 1 878 0
 2224 00fc 0C4B     		ldr	r3, .L135+12
 2225 00fe 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2226 0100 1846     		mov	r0, r3
 2227 0102 0421     		movs	r1, #4
 2228 0104 FFF7FEFF 		bl	CyDmaChSetRequest
 879:main.c        ****     CyDmaChEnable(DMA_Channel_2_Chan, 1);
 2229              		.loc 1 879 0
 2230 0108 094B     		ldr	r3, .L135+12
 2231 010a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2232 010c 1846     		mov	r0, r3
 2233 010e 0121     		movs	r1, #1
 2234 0110 FFF7FEFF 		bl	CyDmaChEnable
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 56


 880:main.c        ****     CyDmaChEnable(DMA_Channel_2_Chan, 1);
 2235              		.loc 1 880 0
 2236 0114 064B     		ldr	r3, .L135+12
 2237 0116 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2238 0118 1846     		mov	r0, r3
 2239 011a 0121     		movs	r1, #1
 2240 011c FFF7FEFF 		bl	CyDmaChEnable
 881:main.c        **** 
 882:main.c        ****     return;
 2241              		.loc 1 882 0
 2242 0120 00BF     		nop
 883:main.c        **** }
 2243              		.loc 1 883 0
 2244 0122 80BD     		pop	{r7, pc}
 2245              	.L136:
 2246              		.align	2
 2247              	.L135:
 2248 0124 00000000 		.word	DMA_Channel_1_Chan
 2249 0128 00000000 		.word	DMA_Channel_1_TD
 2250 012c 00000000 		.word	Channel_1_Data
 2251 0130 00000000 		.word	DMA_Channel_2_Chan
 2252 0134 00000000 		.word	DMA_Channel_2_TD
 2253 0138 00000000 		.word	Channel_2_Data
 2254              		.cfi_endproc
 2255              	.LFE65:
 2256              		.size	DMA_Config, .-DMA_Config
 2257              		.section	.text.GetLastSampleIndex,"ax",%progbits
 2258              		.align	2
 2259              		.global	GetLastSampleIndex
 2260              		.thumb
 2261              		.thumb_func
 2262              		.type	GetLastSampleIndex, %function
 2263              	GetLastSampleIndex:
 2264              	.LFB66:
 884:main.c        **** 
 885:main.c        **** // returns the address of the first sample in the circular DMA buffer
 886:main.c        **** 
 887:main.c        **** uint16 GetLastSampleIndex(uint8 chHandle)
 888:main.c        **** {
 2265              		.loc 1 888 0
 2266              		.cfi_startproc
 2267              		@ args = 0, pretend = 0, frame = 16
 2268              		@ frame_needed = 1, uses_anonymous_args = 0
 2269              		@ link register save eliminated.
 2270 0000 80B4     		push	{r7}
 2271              		.cfi_def_cfa_offset 4
 2272              		.cfi_offset 7, -4
 2273 0002 85B0     		sub	sp, sp, #20
 2274              		.cfi_def_cfa_offset 24
 2275 0004 00AF     		add	r7, sp, #0
 2276              		.cfi_def_cfa_register 7
 2277 0006 0346     		mov	r3, r0
 2278 0008 FB71     		strb	r3, [r7, #7]
 889:main.c        **** 	uint16 index;
 890:main.c        **** 
 891:main.c        **** 	// get the upper 16 bits of the destination (not strictly necessary) (actually it doesn't work sin
 892:main.c        **** 	// upper 16 bit addresses for the same RAM information
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 57


 893:main.c        **** 	//dest_address = (((uint32) CY_DMA_CFGMEM_STRUCT_PTR[chHandle].CFG1[3]) << 24) | (((uint32) CY_DMA
 894:main.c        **** 	
 895:main.c        **** 	// grab the lower 16 bits of the destination address
 896:main.c        **** 	// the assumption here is that "work seperate" has been enabled, so a copy of the TD is stored in 
 897:main.c        **** 	index = ((uint32) CY_DMA_TDMEM_STRUCT_PTR[chHandle].TD1[3] << 8) | ((uint32) CY_DMA_TDMEM_STRUCT_P
 2279              		.loc 1 897 0
 2280 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2281 000c DB00     		lsls	r3, r3, #3
 2282 000e 03F18043 		add	r3, r3, #1073741824
 2283 0012 03F5F043 		add	r3, r3, #30720
 2284 0016 DB79     		ldrb	r3, [r3, #7]
 2285 0018 DBB2     		uxtb	r3, r3
 2286 001a 9BB2     		uxth	r3, r3
 2287 001c 1B02     		lsls	r3, r3, #8
 2288 001e 9AB2     		uxth	r2, r3
 2289 0020 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2290 0022 DB00     		lsls	r3, r3, #3
 2291 0024 03F18043 		add	r3, r3, #1073741824
 2292 0028 03F5F043 		add	r3, r3, #30720
 2293 002c 9B79     		ldrb	r3, [r3, #6]
 2294 002e DBB2     		uxtb	r3, r3
 2295 0030 9BB2     		uxth	r3, r3
 2296 0032 1343     		orrs	r3, r3, r2
 2297 0034 FB81     		strh	r3, [r7, #14]	@ movhi
 898:main.c        **** 	
 899:main.c        **** 	// calculate the index by taking the difference between the starting and ending destination addres
 900:main.c        **** 	index = (index - sizeof(int16) - LO16((uint32) &Channel_1_Data[0]))/sizeof(int16) % BUFFER_SIZE;
 2298              		.loc 1 900 0
 2299 0036 FA89     		ldrh	r2, [r7, #14]
 2300 0038 094B     		ldr	r3, .L139
 2301 003a 9BB2     		uxth	r3, r3
 2302 003c 1946     		mov	r1, r3
 2303 003e 6FF00103 		mvn	r3, #1
 2304 0042 5B1A     		subs	r3, r3, r1
 2305 0044 1344     		add	r3, r3, r2
 2306 0046 5B08     		lsrs	r3, r3, #1
 2307 0048 9BB2     		uxth	r3, r3
 2308 004a C3F30903 		ubfx	r3, r3, #0, #10
 2309 004e FB81     		strh	r3, [r7, #14]	@ movhi
 901:main.c        **** 	
 902:main.c        **** 	return index;
 2310              		.loc 1 902 0
 2311 0050 FB89     		ldrh	r3, [r7, #14]
 903:main.c        **** }
 2312              		.loc 1 903 0
 2313 0052 1846     		mov	r0, r3
 2314 0054 1437     		adds	r7, r7, #20
 2315              		.cfi_def_cfa_offset 4
 2316 0056 BD46     		mov	sp, r7
 2317              		.cfi_def_cfa_register 13
 2318              		@ sp needed
 2319 0058 5DF8047B 		ldr	r7, [sp], #4
 2320              		.cfi_restore 7
 2321              		.cfi_def_cfa_offset 0
 2322 005c 7047     		bx	lr
 2323              	.L140:
 2324 005e 00BF     		.align	2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 58


 2325              	.L139:
 2326 0060 00000000 		.word	Channel_1_Data
 2327              		.cfi_endproc
 2328              	.LFE66:
 2329              		.size	GetLastSampleIndex, .-GetLastSampleIndex
 2330              		.section	.text.CommandCheck,"ax",%progbits
 2331              		.align	2
 2332              		.global	CommandCheck
 2333              		.thumb
 2334              		.thumb_func
 2335              		.type	CommandCheck, %function
 2336              	CommandCheck:
 2337              	.LFB67:
 904:main.c        **** 
 905:main.c        **** void CommandCheck(void)
 906:main.c        **** {
 2338              		.loc 1 906 0
 2339              		.cfi_startproc
 2340              		@ args = 0, pretend = 0, frame = 8
 2341              		@ frame_needed = 1, uses_anonymous_args = 0
 2342 0000 80B5     		push	{r7, lr}
 2343              		.cfi_def_cfa_offset 8
 2344              		.cfi_offset 7, -8
 2345              		.cfi_offset 14, -4
 2346 0002 82B0     		sub	sp, sp, #8
 2347              		.cfi_def_cfa_offset 16
 2348 0004 00AF     		add	r7, sp, #0
 2349              		.cfi_def_cfa_register 7
 907:main.c        **** 	uint16 i, ReceivedBytes;
 908:main.c        **** 	// check to see if line state has changed? thought this might be necessary, but it probably isn't
 909:main.c        **** 	USBUART_IsLineChanged();
 2350              		.loc 1 909 0
 2351 0006 FFF7FEFF 		bl	USBUART_IsLineChanged
 910:main.c        **** 	
 911:main.c        **** 	// if data is waiting
 912:main.c        **** 	if(USBUART_DataIsReady() != 0)
 2352              		.loc 1 912 0
 2353 000a FFF7FEFF 		bl	USBUART_DataIsReady
 2354 000e 0346     		mov	r3, r0
 2355 0010 002B     		cmp	r3, #0
 2356 0012 5AD0     		beq	.L142
 913:main.c        **** 	{
 914:main.c        **** 		// lets find out how much the PC sent to us
 915:main.c        **** 		ReceivedBytes = USBUART_GetCount();
 2357              		.loc 1 915 0
 2358 0014 FFF7FEFF 		bl	USBUART_GetCount
 2359 0018 0346     		mov	r3, r0
 2360 001a BB80     		strh	r3, [r7, #4]	@ movhi
 916:main.c        **** 		
 917:main.c        **** 		// if the amount of data received is non-zero
 918:main.c        **** 		if(ReceivedBytes != 0)
 2361              		.loc 1 918 0
 2362 001c BB88     		ldrh	r3, [r7, #4]
 2363 001e 002B     		cmp	r3, #0
 2364 0020 07D0     		beq	.L143
 919:main.c        **** 		{
 920:main.c        **** 			cCharsReceived = USBUART_GetAll((uint8 *) &szTempBuffer[0]);
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 59


 2365              		.loc 1 920 0
 2366 0022 4F48     		ldr	r0, .L153
 2367 0024 FFF7FEFF 		bl	USBUART_GetAll
 2368 0028 0346     		mov	r3, r0
 2369 002a DAB2     		uxtb	r2, r3
 2370 002c 4D4B     		ldr	r3, .L153+4
 2371 002e 1A70     		strb	r2, [r3]
 2372 0030 02E0     		b	.L144
 2373              	.L143:
 921:main.c        **** 		}
 922:main.c        **** 		else
 923:main.c        **** 		{
 924:main.c        **** 			// its a zero length data packet, it *should* be safe to do this and not worry about corrupting 
 925:main.c        **** 			USBUART_GetAll((uint8 *) &szTempBuffer[0]);
 2374              		.loc 1 925 0
 2375 0032 4B48     		ldr	r0, .L153
 2376 0034 FFF7FEFF 		bl	USBUART_GetAll
 2377              	.L144:
 926:main.c        **** 			//PutString("Zero Length Packet\n");
 927:main.c        **** 		}
 928:main.c        **** 		
 929:main.c        **** 		// move the data from the temporary buffer into the circular command buffer
 930:main.c        **** 		i = 0;
 2378              		.loc 1 930 0
 2379 0038 0023     		movs	r3, #0
 2380 003a FB80     		strh	r3, [r7, #6]	@ movhi
 2381              	.L146:
 931:main.c        **** 		do
 932:main.c        **** 		{
 933:main.c        **** 			szCommandsBuffer[iWrite] = szTempBuffer[i];
 2382              		.loc 1 933 0 discriminator 2
 2383 003c 4A4B     		ldr	r3, .L153+8
 2384 003e 1B88     		ldrh	r3, [r3]
 2385 0040 1946     		mov	r1, r3
 2386 0042 FB88     		ldrh	r3, [r7, #6]
 2387 0044 464A     		ldr	r2, .L153
 2388 0046 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 2389 0048 484B     		ldr	r3, .L153+12
 2390 004a 5A54     		strb	r2, [r3, r1]
 934:main.c        **** 			i++;
 2391              		.loc 1 934 0 discriminator 2
 2392 004c FB88     		ldrh	r3, [r7, #6]
 2393 004e 0133     		adds	r3, r3, #1
 2394 0050 FB80     		strh	r3, [r7, #6]	@ movhi
 935:main.c        **** 			iWrite++;
 2395              		.loc 1 935 0 discriminator 2
 2396 0052 454B     		ldr	r3, .L153+8
 2397 0054 1B88     		ldrh	r3, [r3]
 2398 0056 0133     		adds	r3, r3, #1
 2399 0058 9AB2     		uxth	r2, r3
 2400 005a 434B     		ldr	r3, .L153+8
 2401 005c 1A80     		strh	r2, [r3]	@ movhi
 936:main.c        **** 			iWrite = iWrite % CIRCULAR_BUFFER_SIZE;
 2402              		.loc 1 936 0 discriminator 2
 2403 005e 424B     		ldr	r3, .L153+8
 2404 0060 1B88     		ldrh	r3, [r3]
 2405 0062 C3F30B03 		ubfx	r3, r3, #0, #12
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 60


 2406 0066 9AB2     		uxth	r2, r3
 2407 0068 3F4B     		ldr	r3, .L153+8
 2408 006a 1A80     		strh	r2, [r3]	@ movhi
 937:main.c        **** 		}while((iWrite != iRead) && (i != cCharsReceived));
 2409              		.loc 1 937 0 discriminator 2
 2410 006c 3E4B     		ldr	r3, .L153+8
 2411 006e 1A88     		ldrh	r2, [r3]
 2412 0070 3F4B     		ldr	r3, .L153+16
 2413 0072 1B88     		ldrh	r3, [r3]
 2414 0074 9A42     		cmp	r2, r3
 2415 0076 05D0     		beq	.L145
 2416              		.loc 1 937 0 is_stmt 0 discriminator 1
 2417 0078 3A4B     		ldr	r3, .L153+4
 2418 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2419 007c 9BB2     		uxth	r3, r3
 2420 007e FA88     		ldrh	r2, [r7, #6]
 2421 0080 9A42     		cmp	r2, r3
 2422 0082 DBD1     		bne	.L146
 2423              	.L145:
 938:main.c        **** 		
 939:main.c        **** 		// scan the command buffer for commands
 940:main.c        **** 		i = iRead;
 2424              		.loc 1 940 0 is_stmt 1
 2425 0084 3A4B     		ldr	r3, .L153+16
 2426 0086 1B88     		ldrh	r3, [r3]	@ movhi
 2427 0088 FB80     		strh	r3, [r7, #6]	@ movhi
 2428              	.L149:
 941:main.c        **** 		do
 942:main.c        **** 		{
 943:main.c        **** 			// if we see a carriage return or a line feed
 944:main.c        **** 			if((szCommandsBuffer[i] == '\n') || (szCommandsBuffer[i] == '\r'))
 2429              		.loc 1 944 0
 2430 008a FB88     		ldrh	r3, [r7, #6]
 2431 008c 374A     		ldr	r2, .L153+12
 2432 008e D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2433 0090 0A2B     		cmp	r3, #10
 2434 0092 04D0     		beq	.L147
 2435              		.loc 1 944 0 is_stmt 0 discriminator 1
 2436 0094 FB88     		ldrh	r3, [r7, #6]
 2437 0096 354A     		ldr	r2, .L153+12
 2438 0098 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2439 009a 0D2B     		cmp	r3, #13
 2440 009c 09D1     		bne	.L148
 2441              	.L147:
 945:main.c        **** 			{
 946:main.c        **** 				cCommandsReady++; // indicate the buffer contains commands to be dealt with
 2442              		.loc 1 946 0 is_stmt 1
 2443 009e 354B     		ldr	r3, .L153+20
 2444 00a0 1B88     		ldrh	r3, [r3]
 2445 00a2 0133     		adds	r3, r3, #1
 2446 00a4 9AB2     		uxth	r2, r3
 2447 00a6 334B     		ldr	r3, .L153+20
 2448 00a8 1A80     		strh	r2, [r3]	@ movhi
 947:main.c        **** 				szCommandsBuffer[i] = 0; // null terminate the string
 2449              		.loc 1 947 0
 2450 00aa FB88     		ldrh	r3, [r7, #6]
 2451 00ac 2F4A     		ldr	r2, .L153+12
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 61


 2452 00ae 0021     		movs	r1, #0
 2453 00b0 D154     		strb	r1, [r2, r3]
 2454              	.L148:
 948:main.c        **** 			}
 949:main.c        **** 			i++;
 2455              		.loc 1 949 0
 2456 00b2 FB88     		ldrh	r3, [r7, #6]
 2457 00b4 0133     		adds	r3, r3, #1
 2458 00b6 FB80     		strh	r3, [r7, #6]	@ movhi
 950:main.c        **** 			i = i % CIRCULAR_BUFFER_SIZE;
 2459              		.loc 1 950 0
 2460 00b8 FB88     		ldrh	r3, [r7, #6]	@ movhi
 2461 00ba C3F30B03 		ubfx	r3, r3, #0, #12
 2462 00be FB80     		strh	r3, [r7, #6]	@ movhi
 951:main.c        **** 		}while(i != iWrite);
 2463              		.loc 1 951 0
 2464 00c0 294B     		ldr	r3, .L153+8
 2465 00c2 1B88     		ldrh	r3, [r3]
 2466 00c4 FA88     		ldrh	r2, [r7, #6]
 2467 00c6 9A42     		cmp	r2, r3
 2468 00c8 DFD1     		bne	.L149
 2469              	.L142:
 952:main.c        **** 	}
 953:main.c        **** 	
 954:main.c        **** 	i = 0;
 2470              		.loc 1 954 0
 2471 00ca 0023     		movs	r3, #0
 2472 00cc FB80     		strh	r3, [r7, #6]	@ movhi
 955:main.c        **** 	if(cCommandsReady > 0 && bCommandReady == 0)
 2473              		.loc 1 955 0
 2474 00ce 294B     		ldr	r3, .L153+20
 2475 00d0 1B88     		ldrh	r3, [r3]
 2476 00d2 002B     		cmp	r3, #0
 2477 00d4 40D0     		beq	.L141
 2478              		.loc 1 955 0 is_stmt 0 discriminator 1
 2479 00d6 284B     		ldr	r3, .L153+24
 2480 00d8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2481 00da 002B     		cmp	r3, #0
 2482 00dc 3CD1     		bne	.L141
 956:main.c        **** 	{
 957:main.c        **** 		while(szCommandsBuffer[iRead] != 0)
 2483              		.loc 1 957 0 is_stmt 1
 2484 00de 17E0     		b	.L151
 2485              	.L152:
 958:main.c        **** 		{
 959:main.c        **** 			szCommand[i] = szCommandsBuffer[iRead];
 2486              		.loc 1 959 0
 2487 00e0 FB88     		ldrh	r3, [r7, #6]
 2488 00e2 234A     		ldr	r2, .L153+16
 2489 00e4 1288     		ldrh	r2, [r2]
 2490 00e6 1146     		mov	r1, r2
 2491 00e8 204A     		ldr	r2, .L153+12
 2492 00ea 515C     		ldrb	r1, [r2, r1]	@ zero_extendqisi2
 2493 00ec 234A     		ldr	r2, .L153+28
 2494 00ee D154     		strb	r1, [r2, r3]
 960:main.c        **** 			i++;
 2495              		.loc 1 960 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 62


 2496 00f0 FB88     		ldrh	r3, [r7, #6]
 2497 00f2 0133     		adds	r3, r3, #1
 2498 00f4 FB80     		strh	r3, [r7, #6]	@ movhi
 961:main.c        **** 			iRead++;
 2499              		.loc 1 961 0
 2500 00f6 1E4B     		ldr	r3, .L153+16
 2501 00f8 1B88     		ldrh	r3, [r3]
 2502 00fa 0133     		adds	r3, r3, #1
 2503 00fc 9AB2     		uxth	r2, r3
 2504 00fe 1C4B     		ldr	r3, .L153+16
 2505 0100 1A80     		strh	r2, [r3]	@ movhi
 962:main.c        **** 			iRead = iRead % CIRCULAR_BUFFER_SIZE;
 2506              		.loc 1 962 0
 2507 0102 1B4B     		ldr	r3, .L153+16
 2508 0104 1B88     		ldrh	r3, [r3]
 2509 0106 C3F30B03 		ubfx	r3, r3, #0, #12
 2510 010a 9AB2     		uxth	r2, r3
 2511 010c 184B     		ldr	r3, .L153+16
 2512 010e 1A80     		strh	r2, [r3]	@ movhi
 2513              	.L151:
 957:main.c        **** 		{
 2514              		.loc 1 957 0
 2515 0110 174B     		ldr	r3, .L153+16
 2516 0112 1B88     		ldrh	r3, [r3]
 2517 0114 1A46     		mov	r2, r3
 2518 0116 154B     		ldr	r3, .L153+12
 2519 0118 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 2520 011a 002B     		cmp	r3, #0
 2521 011c E0D1     		bne	.L152
 963:main.c        **** 		}
 964:main.c        **** 		
 965:main.c        **** 		szCommand[i] = 0;
 2522              		.loc 1 965 0
 2523 011e FB88     		ldrh	r3, [r7, #6]
 2524 0120 164A     		ldr	r2, .L153+28
 2525 0122 0021     		movs	r1, #0
 2526 0124 D154     		strb	r1, [r2, r3]
 966:main.c        **** 		iRead++;
 2527              		.loc 1 966 0
 2528 0126 124B     		ldr	r3, .L153+16
 2529 0128 1B88     		ldrh	r3, [r3]
 2530 012a 0133     		adds	r3, r3, #1
 2531 012c 9AB2     		uxth	r2, r3
 2532 012e 104B     		ldr	r3, .L153+16
 2533 0130 1A80     		strh	r2, [r3]	@ movhi
 967:main.c        **** 		iRead = iRead % CIRCULAR_BUFFER_SIZE;
 2534              		.loc 1 967 0
 2535 0132 0F4B     		ldr	r3, .L153+16
 2536 0134 1B88     		ldrh	r3, [r3]
 2537 0136 C3F30B03 		ubfx	r3, r3, #0, #12
 2538 013a 9AB2     		uxth	r2, r3
 2539 013c 0C4B     		ldr	r3, .L153+16
 2540 013e 1A80     		strh	r2, [r3]	@ movhi
 968:main.c        **** 		cCommandsReady--;
 2541              		.loc 1 968 0
 2542 0140 0C4B     		ldr	r3, .L153+20
 2543 0142 1B88     		ldrh	r3, [r3]
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 63


 2544 0144 013B     		subs	r3, r3, #1
 2545 0146 9AB2     		uxth	r2, r3
 2546 0148 0A4B     		ldr	r3, .L153+20
 2547 014a 1A80     		strh	r2, [r3]	@ movhi
 969:main.c        **** 		if(i == 0)
 2548              		.loc 1 969 0
 2549 014c FB88     		ldrh	r3, [r7, #6]
 2550 014e 002B     		cmp	r3, #0
 2551 0150 02D0     		beq	.L141
 970:main.c        **** 		{
 971:main.c        **** 			// this is a zero length command, nothing to do
 972:main.c        **** 		}
 973:main.c        **** 		else
 974:main.c        **** 		{
 975:main.c        **** 			// the command was at least 1 character, report it
 976:main.c        **** 			bCommandReady = 1;
 2552              		.loc 1 976 0
 2553 0152 094B     		ldr	r3, .L153+24
 2554 0154 0122     		movs	r2, #1
 2555 0156 1A70     		strb	r2, [r3]
 2556              	.L141:
 977:main.c        **** 		}
 978:main.c        **** 	}
 979:main.c        **** }
 2557              		.loc 1 979 0
 2558 0158 0837     		adds	r7, r7, #8
 2559              		.cfi_def_cfa_offset 8
 2560 015a BD46     		mov	sp, r7
 2561              		.cfi_def_cfa_register 13
 2562              		@ sp needed
 2563 015c 80BD     		pop	{r7, pc}
 2564              	.L154:
 2565 015e 00BF     		.align	2
 2566              	.L153:
 2567 0160 00000000 		.word	szTempBuffer
 2568 0164 00000000 		.word	cCharsReceived
 2569 0168 00000000 		.word	iWrite
 2570 016c 00000000 		.word	szCommandsBuffer
 2571 0170 00000000 		.word	iRead
 2572 0174 00000000 		.word	cCommandsReady
 2573 0178 00000000 		.word	bCommandReady
 2574 017c 00000000 		.word	szCommand
 2575              		.cfi_endproc
 2576              	.LFE67:
 2577              		.size	CommandCheck, .-CommandCheck
 2578              		.section	.text.PutString,"ax",%progbits
 2579              		.align	2
 2580              		.global	PutString
 2581              		.thumb
 2582              		.thumb_func
 2583              		.type	PutString, %function
 2584              	PutString:
 2585              	.LFB68:
 980:main.c        **** 
 981:main.c        **** void PutString(char * string)
 982:main.c        **** {
 2586              		.loc 1 982 0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 64


 2587              		.cfi_startproc
 2588              		@ args = 0, pretend = 0, frame = 8
 2589              		@ frame_needed = 1, uses_anonymous_args = 0
 2590 0000 80B5     		push	{r7, lr}
 2591              		.cfi_def_cfa_offset 8
 2592              		.cfi_offset 7, -8
 2593              		.cfi_offset 14, -4
 2594 0002 82B0     		sub	sp, sp, #8
 2595              		.cfi_def_cfa_offset 16
 2596 0004 00AF     		add	r7, sp, #0
 2597              		.cfi_def_cfa_register 7
 2598 0006 7860     		str	r0, [r7, #4]
 983:main.c        **** 	while(USBUART_CDCIsReady() == 0){};
 2599              		.loc 1 983 0
 2600 0008 00BF     		nop
 2601              	.L156:
 2602              		.loc 1 983 0 is_stmt 0 discriminator 1
 2603 000a FFF7FEFF 		bl	USBUART_CDCIsReady
 2604 000e 0346     		mov	r3, r0
 2605 0010 002B     		cmp	r3, #0
 2606 0012 FAD0     		beq	.L156
 984:main.c        **** 	USBUART_PutString(string);
 2607              		.loc 1 984 0 is_stmt 1
 2608 0014 7868     		ldr	r0, [r7, #4]
 2609 0016 FFF7FEFF 		bl	USBUART_PutString
 985:main.c        **** }
 2610              		.loc 1 985 0
 2611 001a 0837     		adds	r7, r7, #8
 2612              		.cfi_def_cfa_offset 8
 2613 001c BD46     		mov	sp, r7
 2614              		.cfi_def_cfa_register 13
 2615              		@ sp needed
 2616 001e 80BD     		pop	{r7, pc}
 2617              		.cfi_endproc
 2618              	.LFE68:
 2619              		.size	PutString, .-PutString
 2620              		.section	.text.PutChar,"ax",%progbits
 2621              		.align	2
 2622              		.global	PutChar
 2623              		.thumb
 2624              		.thumb_func
 2625              		.type	PutChar, %function
 2626              	PutChar:
 2627              	.LFB69:
 986:main.c        **** 
 987:main.c        **** void PutChar(char Data)
 988:main.c        **** {
 2628              		.loc 1 988 0
 2629              		.cfi_startproc
 2630              		@ args = 0, pretend = 0, frame = 8
 2631              		@ frame_needed = 1, uses_anonymous_args = 0
 2632 0000 80B5     		push	{r7, lr}
 2633              		.cfi_def_cfa_offset 8
 2634              		.cfi_offset 7, -8
 2635              		.cfi_offset 14, -4
 2636 0002 82B0     		sub	sp, sp, #8
 2637              		.cfi_def_cfa_offset 16
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 65


 2638 0004 00AF     		add	r7, sp, #0
 2639              		.cfi_def_cfa_register 7
 2640 0006 0346     		mov	r3, r0
 2641 0008 FB71     		strb	r3, [r7, #7]
 989:main.c        **** 	while(USBUART_CDCIsReady() == 0){};
 2642              		.loc 1 989 0
 2643 000a 00BF     		nop
 2644              	.L158:
 2645              		.loc 1 989 0 is_stmt 0 discriminator 1
 2646 000c FFF7FEFF 		bl	USBUART_CDCIsReady
 2647 0010 0346     		mov	r3, r0
 2648 0012 002B     		cmp	r3, #0
 2649 0014 FAD0     		beq	.L158
 990:main.c        **** 	USBUART_PutChar(Data);
 2650              		.loc 1 990 0 is_stmt 1
 2651 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2652 0018 1846     		mov	r0, r3
 2653 001a FFF7FEFF 		bl	USBUART_PutChar
 991:main.c        **** }
 2654              		.loc 1 991 0
 2655 001e 0837     		adds	r7, r7, #8
 2656              		.cfi_def_cfa_offset 8
 2657 0020 BD46     		mov	sp, r7
 2658              		.cfi_def_cfa_register 13
 2659              		@ sp needed
 2660 0022 80BD     		pop	{r7, pc}
 2661              		.cfi_endproc
 2662              	.LFE69:
 2663              		.size	PutChar, .-PutChar
 2664              		.text
 2665              	.Letext0:
 2666              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 2667              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 2668              		.file 4 "Generated_Source\\PSoC5/cytypes.h"
 2669              		.file 5 "Generated_Source\\PSoC5/CYDMAC.H"
 2670              		.file 6 "Generated_Source\\PSoC5/core_cm3.h"
 2671              		.section	.debug_info,"",%progbits
 2672              	.Ldebug_info0:
 2673 0000 D8040000 		.4byte	0x4d8
 2674 0004 0400     		.2byte	0x4
 2675 0006 00000000 		.4byte	.Ldebug_abbrev0
 2676 000a 04       		.byte	0x4
 2677 000b 01       		.uleb128 0x1
 2678 000c 28010000 		.4byte	.LASF67
 2679 0010 01       		.byte	0x1
 2680 0011 0D030000 		.4byte	.LASF68
 2681 0015 4B030000 		.4byte	.LASF69
 2682 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2683 001d 00000000 		.4byte	0
 2684 0021 00000000 		.4byte	.Ldebug_line0
 2685 0025 02       		.uleb128 0x2
 2686 0026 01       		.byte	0x1
 2687 0027 06       		.byte	0x6
 2688 0028 27020000 		.4byte	.LASF0
 2689 002c 02       		.uleb128 0x2
 2690 002d 01       		.byte	0x1
 2691 002e 08       		.byte	0x8
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 66


 2692 002f 07020000 		.4byte	.LASF1
 2693 0033 02       		.uleb128 0x2
 2694 0034 02       		.byte	0x2
 2695 0035 05       		.byte	0x5
 2696 0036 2C000000 		.4byte	.LASF2
 2697 003a 02       		.uleb128 0x2
 2698 003b 02       		.byte	0x2
 2699 003c 07       		.byte	0x7
 2700 003d D4020000 		.4byte	.LASF3
 2701 0041 03       		.uleb128 0x3
 2702 0042 41030000 		.4byte	.LASF9
 2703 0046 02       		.byte	0x2
 2704 0047 3F       		.byte	0x3f
 2705 0048 4C000000 		.4byte	0x4c
 2706 004c 02       		.uleb128 0x2
 2707 004d 04       		.byte	0x4
 2708 004e 05       		.byte	0x5
 2709 004f B2020000 		.4byte	.LASF4
 2710 0053 02       		.uleb128 0x2
 2711 0054 04       		.byte	0x4
 2712 0055 07       		.byte	0x7
 2713 0056 19030000 		.4byte	.LASF5
 2714 005a 02       		.uleb128 0x2
 2715 005b 08       		.byte	0x8
 2716 005c 05       		.byte	0x5
 2717 005d 1A010000 		.4byte	.LASF6
 2718 0061 02       		.uleb128 0x2
 2719 0062 08       		.byte	0x8
 2720 0063 07       		.byte	0x7
 2721 0064 33020000 		.4byte	.LASF7
 2722 0068 04       		.uleb128 0x4
 2723 0069 04       		.byte	0x4
 2724 006a 05       		.byte	0x5
 2725 006b 696E7400 		.ascii	"int\000"
 2726 006f 02       		.uleb128 0x2
 2727 0070 04       		.byte	0x4
 2728 0071 07       		.byte	0x7
 2729 0072 4A020000 		.4byte	.LASF8
 2730 0076 03       		.uleb128 0x3
 2731 0077 C0020000 		.4byte	.LASF10
 2732 007b 03       		.byte	0x3
 2733 007c 2C       		.byte	0x2c
 2734 007d 41000000 		.4byte	0x41
 2735 0081 05       		.uleb128 0x5
 2736 0082 E7020000 		.4byte	.LASF11
 2737 0086 04       		.byte	0x4
 2738 0087 9201     		.2byte	0x192
 2739 0089 2C000000 		.4byte	0x2c
 2740 008d 05       		.uleb128 0x5
 2741 008e 6F000000 		.4byte	.LASF12
 2742 0092 04       		.byte	0x4
 2743 0093 9301     		.2byte	0x193
 2744 0095 3A000000 		.4byte	0x3a
 2745 0099 05       		.uleb128 0x5
 2746 009a 06030000 		.4byte	.LASF13
 2747 009e 04       		.byte	0x4
 2748 009f 9401     		.2byte	0x194
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 67


 2749 00a1 53000000 		.4byte	0x53
 2750 00a5 05       		.uleb128 0x5
 2751 00a6 2B030000 		.4byte	.LASF14
 2752 00aa 04       		.byte	0x4
 2753 00ab 9701     		.2byte	0x197
 2754 00ad 4C000000 		.4byte	0x4c
 2755 00b1 02       		.uleb128 0x2
 2756 00b2 04       		.byte	0x4
 2757 00b3 04       		.byte	0x4
 2758 00b4 01010000 		.4byte	.LASF15
 2759 00b8 02       		.uleb128 0x2
 2760 00b9 08       		.byte	0x8
 2761 00ba 04       		.byte	0x4
 2762 00bb 31030000 		.4byte	.LASF16
 2763 00bf 02       		.uleb128 0x2
 2764 00c0 01       		.byte	0x1
 2765 00c1 08       		.byte	0x8
 2766 00c2 AD020000 		.4byte	.LASF17
 2767 00c6 05       		.uleb128 0x5
 2768 00c7 14030000 		.4byte	.LASF18
 2769 00cb 04       		.byte	0x4
 2770 00cc 3C02     		.2byte	0x23c
 2771 00ce D2000000 		.4byte	0xd2
 2772 00d2 06       		.uleb128 0x6
 2773 00d3 81000000 		.4byte	0x81
 2774 00d7 05       		.uleb128 0x5
 2775 00d8 26000000 		.4byte	.LASF19
 2776 00dc 04       		.byte	0x4
 2777 00dd 3D02     		.2byte	0x23d
 2778 00df E3000000 		.4byte	0xe3
 2779 00e3 06       		.uleb128 0x6
 2780 00e4 8D000000 		.4byte	0x8d
 2781 00e8 02       		.uleb128 0x2
 2782 00e9 04       		.byte	0x4
 2783 00ea 07       		.byte	0x7
 2784 00eb 36000000 		.4byte	.LASF20
 2785 00ef 07       		.uleb128 0x7
 2786 00f0 04       		.byte	0x4
 2787 00f1 BF000000 		.4byte	0xbf
 2788 00f5 08       		.uleb128 0x8
 2789 00f6 81000000 		.4byte	0x81
 2790 00fa 05010000 		.4byte	0x105
 2791 00fe 09       		.uleb128 0x9
 2792 00ff E8000000 		.4byte	0xe8
 2793 0103 03       		.byte	0x3
 2794 0104 00       		.byte	0
 2795 0105 0A       		.uleb128 0xa
 2796 0106 00000000 		.4byte	.LASF70
 2797 010a 08       		.byte	0x8
 2798 010b 05       		.byte	0x5
 2799 010c 59       		.byte	0x59
 2800 010d 2A010000 		.4byte	0x12a
 2801 0111 0B       		.uleb128 0xb
 2802 0112 54443000 		.ascii	"TD0\000"
 2803 0116 05       		.byte	0x5
 2804 0117 5B       		.byte	0x5b
 2805 0118 2A010000 		.4byte	0x12a
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 68


 2806 011c 00       		.byte	0
 2807 011d 0B       		.uleb128 0xb
 2808 011e 54443100 		.ascii	"TD1\000"
 2809 0122 05       		.byte	0x5
 2810 0123 5C       		.byte	0x5c
 2811 0124 2F010000 		.4byte	0x12f
 2812 0128 04       		.byte	0x4
 2813 0129 00       		.byte	0
 2814 012a 06       		.uleb128 0x6
 2815 012b F5000000 		.4byte	0xf5
 2816 012f 06       		.uleb128 0x6
 2817 0130 F5000000 		.4byte	0xf5
 2818 0134 03       		.uleb128 0x3
 2819 0135 72020000 		.4byte	.LASF21
 2820 0139 05       		.byte	0x5
 2821 013a 5E       		.byte	0x5e
 2822 013b 05010000 		.4byte	0x105
 2823 013f 0C       		.uleb128 0xc
 2824 0140 BB020000 		.4byte	.LASF33
 2825 0144 01       		.byte	0x1
 2826 0145 74       		.byte	0x74
 2827 0146 68000000 		.4byte	0x68
 2828 014a 00000000 		.4byte	.LFB63
 2829 014e 4C0E0000 		.4byte	.LFE63-.LFB63
 2830 0152 01       		.uleb128 0x1
 2831 0153 9C       		.byte	0x9c
 2832 0154 E3010000 		.4byte	0x1e3
 2833 0158 0D       		.uleb128 0xd
 2834 0159 8C020000 		.4byte	.LASF22
 2835 015d 01       		.byte	0x1
 2836 015e 76       		.byte	0x76
 2837 015f 81000000 		.4byte	0x81
 2838 0163 02       		.uleb128 0x2
 2839 0164 91       		.byte	0x91
 2840 0165 57       		.sleb128 -41
 2841 0166 0D       		.uleb128 0xd
 2842 0167 07010000 		.4byte	.LASF23
 2843 016b 01       		.byte	0x1
 2844 016c 77       		.byte	0x77
 2845 016d 8D000000 		.4byte	0x8d
 2846 0171 02       		.uleb128 0x2
 2847 0172 91       		.byte	0x91
 2848 0173 54       		.sleb128 -44
 2849 0174 0E       		.uleb128 0xe
 2850 0175 70737A00 		.ascii	"psz\000"
 2851 0179 01       		.byte	0x1
 2852 017a 78       		.byte	0x78
 2853 017b EF000000 		.4byte	0xef
 2854 017f 02       		.uleb128 0x2
 2855 0180 91       		.byte	0x91
 2856 0181 5C       		.sleb128 -36
 2857 0182 0D       		.uleb128 0xd
 2858 0183 15020000 		.4byte	.LASF24
 2859 0187 01       		.byte	0x1
 2860 0188 79       		.byte	0x79
 2861 0189 8D000000 		.4byte	0x8d
 2862 018d 02       		.uleb128 0x2
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 69


 2863 018e 91       		.byte	0x91
 2864 018f 52       		.sleb128 -46
 2865 0190 0D       		.uleb128 0xd
 2866 0191 01040000 		.4byte	.LASF25
 2867 0195 01       		.byte	0x1
 2868 0196 79       		.byte	0x79
 2869 0197 8D000000 		.4byte	0x8d
 2870 019b 02       		.uleb128 0x2
 2871 019c 91       		.byte	0x91
 2872 019d 6E       		.sleb128 -18
 2873 019e 0E       		.uleb128 0xe
 2874 019f 6900     		.ascii	"i\000"
 2875 01a1 01       		.byte	0x1
 2876 01a2 79       		.byte	0x79
 2877 01a3 8D000000 		.4byte	0x8d
 2878 01a7 02       		.uleb128 0x2
 2879 01a8 91       		.byte	0x91
 2880 01a9 6C       		.sleb128 -20
 2881 01aa 0D       		.uleb128 0xd
 2882 01ab D8010000 		.4byte	.LASF26
 2883 01af 01       		.byte	0x1
 2884 01b0 7A       		.byte	0x7a
 2885 01b1 99000000 		.4byte	0x99
 2886 01b5 02       		.uleb128 0x2
 2887 01b6 91       		.byte	0x91
 2888 01b7 68       		.sleb128 -24
 2889 01b8 0D       		.uleb128 0xd
 2890 01b9 15010000 		.4byte	.LASF27
 2891 01bd 01       		.byte	0x1
 2892 01be 7B       		.byte	0x7b
 2893 01bf B1000000 		.4byte	0xb1
 2894 01c3 02       		.uleb128 0x2
 2895 01c4 91       		.byte	0x91
 2896 01c5 58       		.sleb128 -40
 2897 01c6 0D       		.uleb128 0xd
 2898 01c7 12000000 		.4byte	.LASF28
 2899 01cb 01       		.byte	0x1
 2900 01cc 7C       		.byte	0x7c
 2901 01cd B1000000 		.4byte	0xb1
 2902 01d1 02       		.uleb128 0x2
 2903 01d2 91       		.byte	0x91
 2904 01d3 64       		.sleb128 -28
 2905 01d4 0D       		.uleb128 0xd
 2906 01d5 E2000000 		.4byte	.LASF29
 2907 01d9 01       		.byte	0x1
 2908 01da 7D       		.byte	0x7d
 2909 01db B1000000 		.4byte	0xb1
 2910 01df 02       		.uleb128 0x2
 2911 01e0 91       		.byte	0x91
 2912 01e1 60       		.sleb128 -32
 2913 01e2 00       		.byte	0
 2914 01e3 0F       		.uleb128 0xf
 2915 01e4 B5000000 		.4byte	.LASF30
 2916 01e8 01       		.byte	0x1
 2917 01e9 1A03     		.2byte	0x31a
 2918 01eb 00000000 		.4byte	.LFB64
 2919 01ef 10010000 		.4byte	.LFE64-.LFB64
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 70


 2920 01f3 01       		.uleb128 0x1
 2921 01f4 9C       		.byte	0x9c
 2922 01f5 0F       		.uleb128 0xf
 2923 01f6 EC000000 		.4byte	.LASF31
 2924 01fa 01       		.byte	0x1
 2925 01fb 5A03     		.2byte	0x35a
 2926 01fd 00000000 		.4byte	.LFB65
 2927 0201 3C010000 		.4byte	.LFE65-.LFB65
 2928 0205 01       		.uleb128 0x1
 2929 0206 9C       		.byte	0x9c
 2930 0207 10       		.uleb128 0x10
 2931 0208 A2000000 		.4byte	.LASF71
 2932 020c 01       		.byte	0x1
 2933 020d 7703     		.2byte	0x377
 2934 020f 8D000000 		.4byte	0x8d
 2935 0213 00000000 		.4byte	.LFB66
 2936 0217 64000000 		.4byte	.LFE66-.LFB66
 2937 021b 01       		.uleb128 0x1
 2938 021c 9C       		.byte	0x9c
 2939 021d 40020000 		.4byte	0x240
 2940 0221 11       		.uleb128 0x11
 2941 0222 38030000 		.4byte	.LASF37
 2942 0226 01       		.byte	0x1
 2943 0227 7703     		.2byte	0x377
 2944 0229 81000000 		.4byte	0x81
 2945 022d 02       		.uleb128 0x2
 2946 022e 91       		.byte	0x91
 2947 022f 6F       		.sleb128 -17
 2948 0230 12       		.uleb128 0x12
 2949 0231 76000000 		.4byte	.LASF32
 2950 0235 01       		.byte	0x1
 2951 0236 7903     		.2byte	0x379
 2952 0238 8D000000 		.4byte	0x8d
 2953 023c 02       		.uleb128 0x2
 2954 023d 91       		.byte	0x91
 2955 023e 76       		.sleb128 -10
 2956 023f 00       		.byte	0
 2957 0240 13       		.uleb128 0x13
 2958 0241 1A020000 		.4byte	.LASF34
 2959 0245 01       		.byte	0x1
 2960 0246 8903     		.2byte	0x389
 2961 0248 00000000 		.4byte	.LFB67
 2962 024c 80010000 		.4byte	.LFE67-.LFB67
 2963 0250 01       		.uleb128 0x1
 2964 0251 9C       		.byte	0x9c
 2965 0252 73020000 		.4byte	0x273
 2966 0256 14       		.uleb128 0x14
 2967 0257 6900     		.ascii	"i\000"
 2968 0259 01       		.byte	0x1
 2969 025a 8B03     		.2byte	0x38b
 2970 025c 8D000000 		.4byte	0x8d
 2971 0260 02       		.uleb128 0x2
 2972 0261 91       		.byte	0x91
 2973 0262 76       		.sleb128 -10
 2974 0263 12       		.uleb128 0x12
 2975 0264 C6030000 		.4byte	.LASF35
 2976 0268 01       		.byte	0x1
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 71


 2977 0269 8B03     		.2byte	0x38b
 2978 026b 8D000000 		.4byte	0x8d
 2979 026f 02       		.uleb128 0x2
 2980 0270 91       		.byte	0x91
 2981 0271 74       		.sleb128 -12
 2982 0272 00       		.byte	0
 2983 0273 13       		.uleb128 0x13
 2984 0274 BC030000 		.4byte	.LASF36
 2985 0278 01       		.byte	0x1
 2986 0279 D503     		.2byte	0x3d5
 2987 027b 00000000 		.4byte	.LFB68
 2988 027f 20000000 		.4byte	.LFE68-.LFB68
 2989 0283 01       		.uleb128 0x1
 2990 0284 9C       		.byte	0x9c
 2991 0285 99020000 		.4byte	0x299
 2992 0289 11       		.uleb128 0x11
 2993 028a BD010000 		.4byte	.LASF38
 2994 028e 01       		.byte	0x1
 2995 028f D503     		.2byte	0x3d5
 2996 0291 EF000000 		.4byte	0xef
 2997 0295 02       		.uleb128 0x2
 2998 0296 91       		.byte	0x91
 2999 0297 74       		.sleb128 -12
 3000 0298 00       		.byte	0
 3001 0299 13       		.uleb128 0x13
 3002 029a FF010000 		.4byte	.LASF39
 3003 029e 01       		.byte	0x1
 3004 029f DB03     		.2byte	0x3db
 3005 02a1 00000000 		.4byte	.LFB69
 3006 02a5 24000000 		.4byte	.LFE69-.LFB69
 3007 02a9 01       		.uleb128 0x1
 3008 02aa 9C       		.byte	0x9c
 3009 02ab BF020000 		.4byte	0x2bf
 3010 02af 11       		.uleb128 0x11
 3011 02b0 C4010000 		.4byte	.LASF40
 3012 02b4 01       		.byte	0x1
 3013 02b5 DB03     		.2byte	0x3db
 3014 02b7 BF000000 		.4byte	0xbf
 3015 02bb 02       		.uleb128 0x2
 3016 02bc 91       		.byte	0x91
 3017 02bd 77       		.sleb128 -9
 3018 02be 00       		.byte	0
 3019 02bf 15       		.uleb128 0x15
 3020 02c0 D4030000 		.4byte	.LASF41
 3021 02c4 06       		.byte	0x6
 3022 02c5 9606     		.2byte	0x696
 3023 02c7 CB020000 		.4byte	0x2cb
 3024 02cb 06       		.uleb128 0x6
 3025 02cc 76000000 		.4byte	0x76
 3026 02d0 16       		.uleb128 0x16
 3027 02d1 E2010000 		.4byte	.LASF42
 3028 02d5 01       		.byte	0x1
 3029 02d6 42       		.byte	0x42
 3030 02d7 81000000 		.4byte	0x81
 3031 02db 05       		.uleb128 0x5
 3032 02dc 03       		.byte	0x3
 3033 02dd 00000000 		.4byte	DMA_Channel_1_Chan
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 72


 3034 02e1 08       		.uleb128 0x8
 3035 02e2 81000000 		.4byte	0x81
 3036 02e6 F1020000 		.4byte	0x2f1
 3037 02ea 09       		.uleb128 0x9
 3038 02eb E8000000 		.4byte	0xe8
 3039 02ef 00       		.byte	0
 3040 02f0 00       		.byte	0
 3041 02f1 16       		.uleb128 0x16
 3042 02f2 F0030000 		.4byte	.LASF43
 3043 02f6 01       		.byte	0x1
 3044 02f7 43       		.byte	0x43
 3045 02f8 E1020000 		.4byte	0x2e1
 3046 02fc 05       		.uleb128 0x5
 3047 02fd 03       		.byte	0x3
 3048 02fe 00000000 		.4byte	DMA_Channel_1_TD
 3049 0302 16       		.uleb128 0x16
 3050 0303 5C000000 		.4byte	.LASF44
 3051 0307 01       		.byte	0x1
 3052 0308 47       		.byte	0x47
 3053 0309 81000000 		.4byte	0x81
 3054 030d 05       		.uleb128 0x5
 3055 030e 03       		.byte	0x3
 3056 030f 00000000 		.4byte	DMA_Channel_2_Chan
 3057 0313 16       		.uleb128 0x16
 3058 0314 7C000000 		.4byte	.LASF45
 3059 0318 01       		.byte	0x1
 3060 0319 48       		.byte	0x48
 3061 031a E1020000 		.4byte	0x2e1
 3062 031e 05       		.uleb128 0x5
 3063 031f 03       		.byte	0x3
 3064 0320 00000000 		.4byte	DMA_Channel_2_TD
 3065 0324 08       		.uleb128 0x8
 3066 0325 8D000000 		.4byte	0x8d
 3067 0329 35030000 		.4byte	0x335
 3068 032d 17       		.uleb128 0x17
 3069 032e E8000000 		.4byte	0xe8
 3070 0332 FF03     		.2byte	0x3ff
 3071 0334 00       		.byte	0
 3072 0335 16       		.uleb128 0x16
 3073 0336 57020000 		.4byte	.LASF46
 3074 033a 01       		.byte	0x1
 3075 033b 4B       		.byte	0x4b
 3076 033c 24030000 		.4byte	0x324
 3077 0340 05       		.uleb128 0x5
 3078 0341 03       		.byte	0x3
 3079 0342 00000000 		.4byte	Channel_1_Data
 3080 0346 16       		.uleb128 0x16
 3081 0347 E1030000 		.4byte	.LASF47
 3082 034b 01       		.byte	0x1
 3083 034c 4C       		.byte	0x4c
 3084 034d 24030000 		.4byte	0x324
 3085 0351 05       		.uleb128 0x5
 3086 0352 03       		.byte	0x3
 3087 0353 00000000 		.4byte	Channel_2_Data
 3088 0357 08       		.uleb128 0x8
 3089 0358 BF000000 		.4byte	0xbf
 3090 035c 67030000 		.4byte	0x367
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 73


 3091 0360 09       		.uleb128 0x9
 3092 0361 E8000000 		.4byte	0xe8
 3093 0365 3F       		.byte	0x3f
 3094 0366 00       		.byte	0
 3095 0367 16       		.uleb128 0x16
 3096 0368 4F000000 		.4byte	.LASF48
 3097 036c 01       		.byte	0x1
 3098 036d 50       		.byte	0x50
 3099 036e 57030000 		.4byte	0x357
 3100 0372 05       		.uleb128 0x5
 3101 0373 03       		.byte	0x3
 3102 0374 00000000 		.4byte	szTempBuffer
 3103 0378 16       		.uleb128 0x16
 3104 0379 7D020000 		.4byte	.LASF49
 3105 037d 01       		.byte	0x1
 3106 037e 51       		.byte	0x51
 3107 037f 81000000 		.4byte	0x81
 3108 0383 05       		.uleb128 0x5
 3109 0384 03       		.byte	0x3
 3110 0385 00000000 		.4byte	cCharsReceived
 3111 0389 08       		.uleb128 0x8
 3112 038a BF000000 		.4byte	0xbf
 3113 038e 9A030000 		.4byte	0x39a
 3114 0392 17       		.uleb128 0x17
 3115 0393 E8000000 		.4byte	0xe8
 3116 0397 FF0F     		.2byte	0xfff
 3117 0399 00       		.byte	0
 3118 039a 16       		.uleb128 0x16
 3119 039b AB030000 		.4byte	.LASF50
 3120 039f 01       		.byte	0x1
 3121 03a0 54       		.byte	0x54
 3122 03a1 89030000 		.4byte	0x389
 3123 03a5 05       		.uleb128 0x5
 3124 03a6 03       		.byte	0x3
 3125 03a7 00000000 		.4byte	szCommandsBuffer
 3126 03ab 16       		.uleb128 0x16
 3127 03ac ED020000 		.4byte	.LASF51
 3128 03b0 01       		.byte	0x1
 3129 03b1 55       		.byte	0x55
 3130 03b2 8D000000 		.4byte	0x8d
 3131 03b6 05       		.uleb128 0x5
 3132 03b7 03       		.byte	0x3
 3133 03b8 00000000 		.4byte	iRead
 3134 03bc 16       		.uleb128 0x16
 3135 03bd B6010000 		.4byte	.LASF52
 3136 03c1 01       		.byte	0x1
 3137 03c2 55       		.byte	0x55
 3138 03c3 8D000000 		.4byte	0x8d
 3139 03c7 05       		.uleb128 0x5
 3140 03c8 03       		.byte	0x3
 3141 03c9 00000000 		.4byte	iWrite
 3142 03cd 16       		.uleb128 0x16
 3143 03ce C5000000 		.4byte	.LASF53
 3144 03d2 01       		.byte	0x1
 3145 03d3 56       		.byte	0x56
 3146 03d4 8D000000 		.4byte	0x8d
 3147 03d8 05       		.uleb128 0x5
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 74


 3148 03d9 03       		.byte	0x3
 3149 03da 00000000 		.4byte	cCommandsReady
 3150 03de 16       		.uleb128 0x16
 3151 03df F5010000 		.4byte	.LASF54
 3152 03e3 01       		.byte	0x1
 3153 03e4 58       		.byte	0x58
 3154 03e5 57030000 		.4byte	0x357
 3155 03e9 05       		.uleb128 0x5
 3156 03ea 03       		.byte	0x3
 3157 03eb 00000000 		.4byte	szCommand
 3158 03ef 16       		.uleb128 0x16
 3159 03f0 D4000000 		.4byte	.LASF55
 3160 03f4 01       		.byte	0x1
 3161 03f5 59       		.byte	0x59
 3162 03f6 81000000 		.4byte	0x81
 3163 03fa 05       		.uleb128 0x5
 3164 03fb 03       		.byte	0x3
 3165 03fc 00000000 		.4byte	bCommandReady
 3166 0400 16       		.uleb128 0x16
 3167 0401 99030000 		.4byte	.LASF56
 3168 0405 01       		.byte	0x1
 3169 0406 5C       		.byte	0x5c
 3170 0407 81000000 		.4byte	0x81
 3171 040b 05       		.uleb128 0x5
 3172 040c 03       		.byte	0x3
 3173 040d 00000000 		.4byte	preamp_a
 3174 0411 16       		.uleb128 0x16
 3175 0412 A2030000 		.4byte	.LASF57
 3176 0416 01       		.byte	0x1
 3177 0417 5C       		.byte	0x5c
 3178 0418 81000000 		.4byte	0x81
 3179 041c 05       		.uleb128 0x5
 3180 041d 03       		.byte	0x3
 3181 041e 00000000 		.4byte	preamp_b
 3182 0422 16       		.uleb128 0x16
 3183 0423 17000000 		.4byte	.LASF58
 3184 0427 01       		.byte	0x1
 3185 0428 5C       		.byte	0x5c
 3186 0429 81000000 		.4byte	0x81
 3187 042d 05       		.uleb128 0x5
 3188 042e 03       		.byte	0x3
 3189 042f 00000000 		.4byte	trigger_source
 3190 0433 16       		.uleb128 0x16
 3191 0434 66020000 		.4byte	.LASF59
 3192 0438 01       		.byte	0x1
 3193 0439 5C       		.byte	0x5c
 3194 043a 81000000 		.4byte	0x81
 3195 043e 05       		.uleb128 0x5
 3196 043f 03       		.byte	0x3
 3197 0440 00000000 		.4byte	preamp_trig
 3198 0444 08       		.uleb128 0x8
 3199 0445 81000000 		.4byte	0x81
 3200 0449 54040000 		.4byte	0x454
 3201 044d 09       		.uleb128 0x9
 3202 044e E8000000 		.4byte	0xe8
 3203 0452 3F       		.byte	0x3f
 3204 0453 00       		.byte	0
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 75


 3205 0454 16       		.uleb128 0x16
 3206 0455 C9010000 		.4byte	.LASF60
 3207 0459 01       		.byte	0x1
 3208 045a 61       		.byte	0x61
 3209 045b 44040000 		.4byte	0x444
 3210 045f 05       		.uleb128 0x5
 3211 0460 03       		.byte	0x3
 3212 0461 00000000 		.4byte	USB_Out_Buffer
 3213 0465 08       		.uleb128 0x8
 3214 0466 81000000 		.4byte	0x81
 3215 046a 75040000 		.4byte	0x475
 3216 046e 09       		.uleb128 0x9
 3217 046f E8000000 		.4byte	0xe8
 3218 0473 FF       		.byte	0xff
 3219 0474 00       		.byte	0
 3220 0475 16       		.uleb128 0x16
 3221 0476 3F000000 		.4byte	.LASF61
 3222 047a 01       		.byte	0x1
 3223 047b 65       		.byte	0x65
 3224 047c 65040000 		.4byte	0x465
 3225 0480 05       		.uleb128 0x5
 3226 0481 03       		.byte	0x3
 3227 0482 00000000 		.4byte	Waveform_Buffer
 3228 0486 16       		.uleb128 0x16
 3229 0487 8D000000 		.4byte	.LASF62
 3230 048b 01       		.byte	0x1
 3231 048c 66       		.byte	0x66
 3232 048d 65040000 		.4byte	0x465
 3233 0491 05       		.uleb128 0x5
 3234 0492 03       		.byte	0x3
 3235 0493 00000000 		.4byte	Waveform_Temp_Buffer
 3236 0497 16       		.uleb128 0x16
 3237 0498 F7000000 		.4byte	.LASF63
 3238 049c 01       		.byte	0x1
 3239 049d 67       		.byte	0x67
 3240 049e 81000000 		.4byte	0x81
 3241 04a2 05       		.uleb128 0x5
 3242 04a3 03       		.byte	0x3
 3243 04a4 00000000 		.4byte	wave_gain
 3244 04a8 16       		.uleb128 0x16
 3245 04a9 C8020000 		.4byte	.LASF64
 3246 04ad 01       		.byte	0x1
 3247 04ae 68       		.byte	0x68
 3248 04af 81000000 		.4byte	0x81
 3249 04b3 05       		.uleb128 0x5
 3250 04b4 03       		.byte	0x3
 3251 04b5 00000000 		.4byte	wave_offset
 3252 04b9 16       		.uleb128 0x16
 3253 04ba 93020000 		.4byte	.LASF65
 3254 04be 01       		.byte	0x1
 3255 04bf 6B       		.byte	0x6b
 3256 04c0 81000000 		.4byte	0x81
 3257 04c4 05       		.uleb128 0x5
 3258 04c5 03       		.byte	0x3
 3259 04c6 00000000 		.4byte	Digital_Input_Status_Last
 3260 04ca 16       		.uleb128 0x16
 3261 04cb F3020000 		.4byte	.LASF66
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 76


 3262 04cf 01       		.byte	0x1
 3263 04d0 6C       		.byte	0x6c
 3264 04d1 81000000 		.4byte	0x81
 3265 04d5 05       		.uleb128 0x5
 3266 04d6 03       		.byte	0x3
 3267 04d7 00000000 		.4byte	Digital_AutoUpdate
 3268 04db 00       		.byte	0
 3269              		.section	.debug_abbrev,"",%progbits
 3270              	.Ldebug_abbrev0:
 3271 0000 01       		.uleb128 0x1
 3272 0001 11       		.uleb128 0x11
 3273 0002 01       		.byte	0x1
 3274 0003 25       		.uleb128 0x25
 3275 0004 0E       		.uleb128 0xe
 3276 0005 13       		.uleb128 0x13
 3277 0006 0B       		.uleb128 0xb
 3278 0007 03       		.uleb128 0x3
 3279 0008 0E       		.uleb128 0xe
 3280 0009 1B       		.uleb128 0x1b
 3281 000a 0E       		.uleb128 0xe
 3282 000b 55       		.uleb128 0x55
 3283 000c 17       		.uleb128 0x17
 3284 000d 11       		.uleb128 0x11
 3285 000e 01       		.uleb128 0x1
 3286 000f 10       		.uleb128 0x10
 3287 0010 17       		.uleb128 0x17
 3288 0011 00       		.byte	0
 3289 0012 00       		.byte	0
 3290 0013 02       		.uleb128 0x2
 3291 0014 24       		.uleb128 0x24
 3292 0015 00       		.byte	0
 3293 0016 0B       		.uleb128 0xb
 3294 0017 0B       		.uleb128 0xb
 3295 0018 3E       		.uleb128 0x3e
 3296 0019 0B       		.uleb128 0xb
 3297 001a 03       		.uleb128 0x3
 3298 001b 0E       		.uleb128 0xe
 3299 001c 00       		.byte	0
 3300 001d 00       		.byte	0
 3301 001e 03       		.uleb128 0x3
 3302 001f 16       		.uleb128 0x16
 3303 0020 00       		.byte	0
 3304 0021 03       		.uleb128 0x3
 3305 0022 0E       		.uleb128 0xe
 3306 0023 3A       		.uleb128 0x3a
 3307 0024 0B       		.uleb128 0xb
 3308 0025 3B       		.uleb128 0x3b
 3309 0026 0B       		.uleb128 0xb
 3310 0027 49       		.uleb128 0x49
 3311 0028 13       		.uleb128 0x13
 3312 0029 00       		.byte	0
 3313 002a 00       		.byte	0
 3314 002b 04       		.uleb128 0x4
 3315 002c 24       		.uleb128 0x24
 3316 002d 00       		.byte	0
 3317 002e 0B       		.uleb128 0xb
 3318 002f 0B       		.uleb128 0xb
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 77


 3319 0030 3E       		.uleb128 0x3e
 3320 0031 0B       		.uleb128 0xb
 3321 0032 03       		.uleb128 0x3
 3322 0033 08       		.uleb128 0x8
 3323 0034 00       		.byte	0
 3324 0035 00       		.byte	0
 3325 0036 05       		.uleb128 0x5
 3326 0037 16       		.uleb128 0x16
 3327 0038 00       		.byte	0
 3328 0039 03       		.uleb128 0x3
 3329 003a 0E       		.uleb128 0xe
 3330 003b 3A       		.uleb128 0x3a
 3331 003c 0B       		.uleb128 0xb
 3332 003d 3B       		.uleb128 0x3b
 3333 003e 05       		.uleb128 0x5
 3334 003f 49       		.uleb128 0x49
 3335 0040 13       		.uleb128 0x13
 3336 0041 00       		.byte	0
 3337 0042 00       		.byte	0
 3338 0043 06       		.uleb128 0x6
 3339 0044 35       		.uleb128 0x35
 3340 0045 00       		.byte	0
 3341 0046 49       		.uleb128 0x49
 3342 0047 13       		.uleb128 0x13
 3343 0048 00       		.byte	0
 3344 0049 00       		.byte	0
 3345 004a 07       		.uleb128 0x7
 3346 004b 0F       		.uleb128 0xf
 3347 004c 00       		.byte	0
 3348 004d 0B       		.uleb128 0xb
 3349 004e 0B       		.uleb128 0xb
 3350 004f 49       		.uleb128 0x49
 3351 0050 13       		.uleb128 0x13
 3352 0051 00       		.byte	0
 3353 0052 00       		.byte	0
 3354 0053 08       		.uleb128 0x8
 3355 0054 01       		.uleb128 0x1
 3356 0055 01       		.byte	0x1
 3357 0056 49       		.uleb128 0x49
 3358 0057 13       		.uleb128 0x13
 3359 0058 01       		.uleb128 0x1
 3360 0059 13       		.uleb128 0x13
 3361 005a 00       		.byte	0
 3362 005b 00       		.byte	0
 3363 005c 09       		.uleb128 0x9
 3364 005d 21       		.uleb128 0x21
 3365 005e 00       		.byte	0
 3366 005f 49       		.uleb128 0x49
 3367 0060 13       		.uleb128 0x13
 3368 0061 2F       		.uleb128 0x2f
 3369 0062 0B       		.uleb128 0xb
 3370 0063 00       		.byte	0
 3371 0064 00       		.byte	0
 3372 0065 0A       		.uleb128 0xa
 3373 0066 13       		.uleb128 0x13
 3374 0067 01       		.byte	0x1
 3375 0068 03       		.uleb128 0x3
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 78


 3376 0069 0E       		.uleb128 0xe
 3377 006a 0B       		.uleb128 0xb
 3378 006b 0B       		.uleb128 0xb
 3379 006c 3A       		.uleb128 0x3a
 3380 006d 0B       		.uleb128 0xb
 3381 006e 3B       		.uleb128 0x3b
 3382 006f 0B       		.uleb128 0xb
 3383 0070 01       		.uleb128 0x1
 3384 0071 13       		.uleb128 0x13
 3385 0072 00       		.byte	0
 3386 0073 00       		.byte	0
 3387 0074 0B       		.uleb128 0xb
 3388 0075 0D       		.uleb128 0xd
 3389 0076 00       		.byte	0
 3390 0077 03       		.uleb128 0x3
 3391 0078 08       		.uleb128 0x8
 3392 0079 3A       		.uleb128 0x3a
 3393 007a 0B       		.uleb128 0xb
 3394 007b 3B       		.uleb128 0x3b
 3395 007c 0B       		.uleb128 0xb
 3396 007d 49       		.uleb128 0x49
 3397 007e 13       		.uleb128 0x13
 3398 007f 38       		.uleb128 0x38
 3399 0080 0B       		.uleb128 0xb
 3400 0081 00       		.byte	0
 3401 0082 00       		.byte	0
 3402 0083 0C       		.uleb128 0xc
 3403 0084 2E       		.uleb128 0x2e
 3404 0085 01       		.byte	0x1
 3405 0086 3F       		.uleb128 0x3f
 3406 0087 19       		.uleb128 0x19
 3407 0088 03       		.uleb128 0x3
 3408 0089 0E       		.uleb128 0xe
 3409 008a 3A       		.uleb128 0x3a
 3410 008b 0B       		.uleb128 0xb
 3411 008c 3B       		.uleb128 0x3b
 3412 008d 0B       		.uleb128 0xb
 3413 008e 49       		.uleb128 0x49
 3414 008f 13       		.uleb128 0x13
 3415 0090 11       		.uleb128 0x11
 3416 0091 01       		.uleb128 0x1
 3417 0092 12       		.uleb128 0x12
 3418 0093 06       		.uleb128 0x6
 3419 0094 40       		.uleb128 0x40
 3420 0095 18       		.uleb128 0x18
 3421 0096 9642     		.uleb128 0x2116
 3422 0098 19       		.uleb128 0x19
 3423 0099 01       		.uleb128 0x1
 3424 009a 13       		.uleb128 0x13
 3425 009b 00       		.byte	0
 3426 009c 00       		.byte	0
 3427 009d 0D       		.uleb128 0xd
 3428 009e 34       		.uleb128 0x34
 3429 009f 00       		.byte	0
 3430 00a0 03       		.uleb128 0x3
 3431 00a1 0E       		.uleb128 0xe
 3432 00a2 3A       		.uleb128 0x3a
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 79


 3433 00a3 0B       		.uleb128 0xb
 3434 00a4 3B       		.uleb128 0x3b
 3435 00a5 0B       		.uleb128 0xb
 3436 00a6 49       		.uleb128 0x49
 3437 00a7 13       		.uleb128 0x13
 3438 00a8 02       		.uleb128 0x2
 3439 00a9 18       		.uleb128 0x18
 3440 00aa 00       		.byte	0
 3441 00ab 00       		.byte	0
 3442 00ac 0E       		.uleb128 0xe
 3443 00ad 34       		.uleb128 0x34
 3444 00ae 00       		.byte	0
 3445 00af 03       		.uleb128 0x3
 3446 00b0 08       		.uleb128 0x8
 3447 00b1 3A       		.uleb128 0x3a
 3448 00b2 0B       		.uleb128 0xb
 3449 00b3 3B       		.uleb128 0x3b
 3450 00b4 0B       		.uleb128 0xb
 3451 00b5 49       		.uleb128 0x49
 3452 00b6 13       		.uleb128 0x13
 3453 00b7 02       		.uleb128 0x2
 3454 00b8 18       		.uleb128 0x18
 3455 00b9 00       		.byte	0
 3456 00ba 00       		.byte	0
 3457 00bb 0F       		.uleb128 0xf
 3458 00bc 2E       		.uleb128 0x2e
 3459 00bd 00       		.byte	0
 3460 00be 3F       		.uleb128 0x3f
 3461 00bf 19       		.uleb128 0x19
 3462 00c0 03       		.uleb128 0x3
 3463 00c1 0E       		.uleb128 0xe
 3464 00c2 3A       		.uleb128 0x3a
 3465 00c3 0B       		.uleb128 0xb
 3466 00c4 3B       		.uleb128 0x3b
 3467 00c5 05       		.uleb128 0x5
 3468 00c6 27       		.uleb128 0x27
 3469 00c7 19       		.uleb128 0x19
 3470 00c8 11       		.uleb128 0x11
 3471 00c9 01       		.uleb128 0x1
 3472 00ca 12       		.uleb128 0x12
 3473 00cb 06       		.uleb128 0x6
 3474 00cc 40       		.uleb128 0x40
 3475 00cd 18       		.uleb128 0x18
 3476 00ce 9642     		.uleb128 0x2116
 3477 00d0 19       		.uleb128 0x19
 3478 00d1 00       		.byte	0
 3479 00d2 00       		.byte	0
 3480 00d3 10       		.uleb128 0x10
 3481 00d4 2E       		.uleb128 0x2e
 3482 00d5 01       		.byte	0x1
 3483 00d6 3F       		.uleb128 0x3f
 3484 00d7 19       		.uleb128 0x19
 3485 00d8 03       		.uleb128 0x3
 3486 00d9 0E       		.uleb128 0xe
 3487 00da 3A       		.uleb128 0x3a
 3488 00db 0B       		.uleb128 0xb
 3489 00dc 3B       		.uleb128 0x3b
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 80


 3490 00dd 05       		.uleb128 0x5
 3491 00de 27       		.uleb128 0x27
 3492 00df 19       		.uleb128 0x19
 3493 00e0 49       		.uleb128 0x49
 3494 00e1 13       		.uleb128 0x13
 3495 00e2 11       		.uleb128 0x11
 3496 00e3 01       		.uleb128 0x1
 3497 00e4 12       		.uleb128 0x12
 3498 00e5 06       		.uleb128 0x6
 3499 00e6 40       		.uleb128 0x40
 3500 00e7 18       		.uleb128 0x18
 3501 00e8 9742     		.uleb128 0x2117
 3502 00ea 19       		.uleb128 0x19
 3503 00eb 01       		.uleb128 0x1
 3504 00ec 13       		.uleb128 0x13
 3505 00ed 00       		.byte	0
 3506 00ee 00       		.byte	0
 3507 00ef 11       		.uleb128 0x11
 3508 00f0 05       		.uleb128 0x5
 3509 00f1 00       		.byte	0
 3510 00f2 03       		.uleb128 0x3
 3511 00f3 0E       		.uleb128 0xe
 3512 00f4 3A       		.uleb128 0x3a
 3513 00f5 0B       		.uleb128 0xb
 3514 00f6 3B       		.uleb128 0x3b
 3515 00f7 05       		.uleb128 0x5
 3516 00f8 49       		.uleb128 0x49
 3517 00f9 13       		.uleb128 0x13
 3518 00fa 02       		.uleb128 0x2
 3519 00fb 18       		.uleb128 0x18
 3520 00fc 00       		.byte	0
 3521 00fd 00       		.byte	0
 3522 00fe 12       		.uleb128 0x12
 3523 00ff 34       		.uleb128 0x34
 3524 0100 00       		.byte	0
 3525 0101 03       		.uleb128 0x3
 3526 0102 0E       		.uleb128 0xe
 3527 0103 3A       		.uleb128 0x3a
 3528 0104 0B       		.uleb128 0xb
 3529 0105 3B       		.uleb128 0x3b
 3530 0106 05       		.uleb128 0x5
 3531 0107 49       		.uleb128 0x49
 3532 0108 13       		.uleb128 0x13
 3533 0109 02       		.uleb128 0x2
 3534 010a 18       		.uleb128 0x18
 3535 010b 00       		.byte	0
 3536 010c 00       		.byte	0
 3537 010d 13       		.uleb128 0x13
 3538 010e 2E       		.uleb128 0x2e
 3539 010f 01       		.byte	0x1
 3540 0110 3F       		.uleb128 0x3f
 3541 0111 19       		.uleb128 0x19
 3542 0112 03       		.uleb128 0x3
 3543 0113 0E       		.uleb128 0xe
 3544 0114 3A       		.uleb128 0x3a
 3545 0115 0B       		.uleb128 0xb
 3546 0116 3B       		.uleb128 0x3b
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 81


 3547 0117 05       		.uleb128 0x5
 3548 0118 27       		.uleb128 0x27
 3549 0119 19       		.uleb128 0x19
 3550 011a 11       		.uleb128 0x11
 3551 011b 01       		.uleb128 0x1
 3552 011c 12       		.uleb128 0x12
 3553 011d 06       		.uleb128 0x6
 3554 011e 40       		.uleb128 0x40
 3555 011f 18       		.uleb128 0x18
 3556 0120 9642     		.uleb128 0x2116
 3557 0122 19       		.uleb128 0x19
 3558 0123 01       		.uleb128 0x1
 3559 0124 13       		.uleb128 0x13
 3560 0125 00       		.byte	0
 3561 0126 00       		.byte	0
 3562 0127 14       		.uleb128 0x14
 3563 0128 34       		.uleb128 0x34
 3564 0129 00       		.byte	0
 3565 012a 03       		.uleb128 0x3
 3566 012b 08       		.uleb128 0x8
 3567 012c 3A       		.uleb128 0x3a
 3568 012d 0B       		.uleb128 0xb
 3569 012e 3B       		.uleb128 0x3b
 3570 012f 05       		.uleb128 0x5
 3571 0130 49       		.uleb128 0x49
 3572 0131 13       		.uleb128 0x13
 3573 0132 02       		.uleb128 0x2
 3574 0133 18       		.uleb128 0x18
 3575 0134 00       		.byte	0
 3576 0135 00       		.byte	0
 3577 0136 15       		.uleb128 0x15
 3578 0137 34       		.uleb128 0x34
 3579 0138 00       		.byte	0
 3580 0139 03       		.uleb128 0x3
 3581 013a 0E       		.uleb128 0xe
 3582 013b 3A       		.uleb128 0x3a
 3583 013c 0B       		.uleb128 0xb
 3584 013d 3B       		.uleb128 0x3b
 3585 013e 05       		.uleb128 0x5
 3586 013f 49       		.uleb128 0x49
 3587 0140 13       		.uleb128 0x13
 3588 0141 3F       		.uleb128 0x3f
 3589 0142 19       		.uleb128 0x19
 3590 0143 3C       		.uleb128 0x3c
 3591 0144 19       		.uleb128 0x19
 3592 0145 00       		.byte	0
 3593 0146 00       		.byte	0
 3594 0147 16       		.uleb128 0x16
 3595 0148 34       		.uleb128 0x34
 3596 0149 00       		.byte	0
 3597 014a 03       		.uleb128 0x3
 3598 014b 0E       		.uleb128 0xe
 3599 014c 3A       		.uleb128 0x3a
 3600 014d 0B       		.uleb128 0xb
 3601 014e 3B       		.uleb128 0x3b
 3602 014f 0B       		.uleb128 0xb
 3603 0150 49       		.uleb128 0x49
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 82


 3604 0151 13       		.uleb128 0x13
 3605 0152 3F       		.uleb128 0x3f
 3606 0153 19       		.uleb128 0x19
 3607 0154 02       		.uleb128 0x2
 3608 0155 18       		.uleb128 0x18
 3609 0156 00       		.byte	0
 3610 0157 00       		.byte	0
 3611 0158 17       		.uleb128 0x17
 3612 0159 21       		.uleb128 0x21
 3613 015a 00       		.byte	0
 3614 015b 49       		.uleb128 0x49
 3615 015c 13       		.uleb128 0x13
 3616 015d 2F       		.uleb128 0x2f
 3617 015e 05       		.uleb128 0x5
 3618 015f 00       		.byte	0
 3619 0160 00       		.byte	0
 3620 0161 00       		.byte	0
 3621              		.section	.debug_aranges,"",%progbits
 3622 0000 4C000000 		.4byte	0x4c
 3623 0004 0200     		.2byte	0x2
 3624 0006 00000000 		.4byte	.Ldebug_info0
 3625 000a 04       		.byte	0x4
 3626 000b 00       		.byte	0
 3627 000c 0000     		.2byte	0
 3628 000e 0000     		.2byte	0
 3629 0010 00000000 		.4byte	.LFB63
 3630 0014 4C0E0000 		.4byte	.LFE63-.LFB63
 3631 0018 00000000 		.4byte	.LFB64
 3632 001c 10010000 		.4byte	.LFE64-.LFB64
 3633 0020 00000000 		.4byte	.LFB65
 3634 0024 3C010000 		.4byte	.LFE65-.LFB65
 3635 0028 00000000 		.4byte	.LFB66
 3636 002c 64000000 		.4byte	.LFE66-.LFB66
 3637 0030 00000000 		.4byte	.LFB67
 3638 0034 80010000 		.4byte	.LFE67-.LFB67
 3639 0038 00000000 		.4byte	.LFB68
 3640 003c 20000000 		.4byte	.LFE68-.LFB68
 3641 0040 00000000 		.4byte	.LFB69
 3642 0044 24000000 		.4byte	.LFE69-.LFB69
 3643 0048 00000000 		.4byte	0
 3644 004c 00000000 		.4byte	0
 3645              		.section	.debug_ranges,"",%progbits
 3646              	.Ldebug_ranges0:
 3647 0000 00000000 		.4byte	.LFB63
 3648 0004 4C0E0000 		.4byte	.LFE63
 3649 0008 00000000 		.4byte	.LFB64
 3650 000c 10010000 		.4byte	.LFE64
 3651 0010 00000000 		.4byte	.LFB65
 3652 0014 3C010000 		.4byte	.LFE65
 3653 0018 00000000 		.4byte	.LFB66
 3654 001c 64000000 		.4byte	.LFE66
 3655 0020 00000000 		.4byte	.LFB67
 3656 0024 80010000 		.4byte	.LFE67
 3657 0028 00000000 		.4byte	.LFB68
 3658 002c 20000000 		.4byte	.LFE68
 3659 0030 00000000 		.4byte	.LFB69
 3660 0034 24000000 		.4byte	.LFE69
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 83


 3661 0038 00000000 		.4byte	0
 3662 003c 00000000 		.4byte	0
 3663              		.section	.debug_line,"",%progbits
 3664              	.Ldebug_line0:
 3665 0000 EB030000 		.section	.debug_str,"MS",%progbits,1
 3665      02005301 
 3665      00000201 
 3665      FB0E0D00 
 3665      01010101 
 3666              	.LASF70:
 3667 0000 646D6163 		.ascii	"dmac_tdmem_struct\000"
 3667      5F74646D 
 3667      656D5F73 
 3667      74727563 
 3667      7400
 3668              	.LASF28:
 3669 0012 63766172 		.ascii	"cvar\000"
 3669      00
 3670              	.LASF58:
 3671 0017 74726967 		.ascii	"trigger_source\000"
 3671      6765725F 
 3671      736F7572 
 3671      636500
 3672              	.LASF19:
 3673 0026 72656731 		.ascii	"reg16\000"
 3673      3600
 3674              	.LASF2:
 3675 002c 73686F72 		.ascii	"short int\000"
 3675      7420696E 
 3675      7400
 3676              	.LASF20:
 3677 0036 73697A65 		.ascii	"sizetype\000"
 3677      74797065 
 3677      00
 3678              	.LASF61:
 3679 003f 57617665 		.ascii	"Waveform_Buffer\000"
 3679      666F726D 
 3679      5F427566 
 3679      66657200 
 3680              	.LASF48:
 3681 004f 737A5465 		.ascii	"szTempBuffer\000"
 3681      6D704275 
 3681      66666572 
 3681      00
 3682              	.LASF44:
 3683 005c 444D415F 		.ascii	"DMA_Channel_2_Chan\000"
 3683      4368616E 
 3683      6E656C5F 
 3683      325F4368 
 3683      616E00
 3684              	.LASF12:
 3685 006f 75696E74 		.ascii	"uint16\000"
 3685      313600
 3686              	.LASF32:
 3687 0076 696E6465 		.ascii	"index\000"
 3687      7800
 3688              	.LASF45:
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 84


 3689 007c 444D415F 		.ascii	"DMA_Channel_2_TD\000"
 3689      4368616E 
 3689      6E656C5F 
 3689      325F5444 
 3689      00
 3690              	.LASF62:
 3691 008d 57617665 		.ascii	"Waveform_Temp_Buffer\000"
 3691      666F726D 
 3691      5F54656D 
 3691      705F4275 
 3691      66666572 
 3692              	.LASF71:
 3693 00a2 4765744C 		.ascii	"GetLastSampleIndex\000"
 3693      61737453 
 3693      616D706C 
 3693      65496E64 
 3693      657800
 3694              	.LASF30:
 3695 00b5 48617264 		.ascii	"Hardware_Config\000"
 3695      77617265 
 3695      5F436F6E 
 3695      66696700 
 3696              	.LASF53:
 3697 00c5 63436F6D 		.ascii	"cCommandsReady\000"
 3697      6D616E64 
 3697      73526561 
 3697      647900
 3698              	.LASF55:
 3699 00d4 62436F6D 		.ascii	"bCommandReady\000"
 3699      6D616E64 
 3699      52656164 
 3699      7900
 3700              	.LASF29:
 3701 00e2 77617665 		.ascii	"wave_temp\000"
 3701      5F74656D 
 3701      7000
 3702              	.LASF31:
 3703 00ec 444D415F 		.ascii	"DMA_Config\000"
 3703      436F6E66 
 3703      696700
 3704              	.LASF63:
 3705 00f7 77617665 		.ascii	"wave_gain\000"
 3705      5F676169 
 3705      6E00
 3706              	.LASF15:
 3707 0101 666C6F61 		.ascii	"float\000"
 3707      7400
 3708              	.LASF23:
 3709 0107 656E6469 		.ascii	"ending_offset\000"
 3709      6E675F6F 
 3709      66667365 
 3709      7400
 3710              	.LASF27:
 3711 0115 66726571 		.ascii	"freq\000"
 3711      00
 3712              	.LASF6:
 3713 011a 6C6F6E67 		.ascii	"long long int\000"
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 85


 3713      206C6F6E 
 3713      6720696E 
 3713      7400
 3714              	.LASF67:
 3715 0128 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 3715      4320342E 
 3715      392E3320 
 3715      32303135 
 3715      30333033 
 3716 015b 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 3716      20726576 
 3716      6973696F 
 3716      6E203232 
 3716      31323230 
 3717 018e 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 3717      66756E63 
 3717      74696F6E 
 3717      2D736563 
 3717      74696F6E 
 3718              	.LASF52:
 3719 01b6 69577269 		.ascii	"iWrite\000"
 3719      746500
 3720              	.LASF38:
 3721 01bd 73747269 		.ascii	"string\000"
 3721      6E6700
 3722              	.LASF40:
 3723 01c4 44617461 		.ascii	"Data\000"
 3723      00
 3724              	.LASF60:
 3725 01c9 5553425F 		.ascii	"USB_Out_Buffer\000"
 3725      4F75745F 
 3725      42756666 
 3725      657200
 3726              	.LASF26:
 3727 01d8 70686173 		.ascii	"phase_int\000"
 3727      655F696E 
 3727      7400
 3728              	.LASF42:
 3729 01e2 444D415F 		.ascii	"DMA_Channel_1_Chan\000"
 3729      4368616E 
 3729      6E656C5F 
 3729      315F4368 
 3729      616E00
 3730              	.LASF54:
 3731 01f5 737A436F 		.ascii	"szCommand\000"
 3731      6D6D616E 
 3731      6400
 3732              	.LASF39:
 3733 01ff 50757443 		.ascii	"PutChar\000"
 3733      68617200 
 3734              	.LASF1:
 3735 0207 756E7369 		.ascii	"unsigned char\000"
 3735      676E6564 
 3735      20636861 
 3735      7200
 3736              	.LASF24:
 3737 0215 61766172 		.ascii	"avar\000"
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 86


 3737      00
 3738              	.LASF34:
 3739 021a 436F6D6D 		.ascii	"CommandCheck\000"
 3739      616E6443 
 3739      6865636B 
 3739      00
 3740              	.LASF0:
 3741 0227 7369676E 		.ascii	"signed char\000"
 3741      65642063 
 3741      68617200 
 3742              	.LASF7:
 3743 0233 6C6F6E67 		.ascii	"long long unsigned int\000"
 3743      206C6F6E 
 3743      6720756E 
 3743      7369676E 
 3743      65642069 
 3744              	.LASF8:
 3745 024a 756E7369 		.ascii	"unsigned int\000"
 3745      676E6564 
 3745      20696E74 
 3745      00
 3746              	.LASF46:
 3747 0257 4368616E 		.ascii	"Channel_1_Data\000"
 3747      6E656C5F 
 3747      315F4461 
 3747      746100
 3748              	.LASF59:
 3749 0266 70726561 		.ascii	"preamp_trig\000"
 3749      6D705F74 
 3749      72696700 
 3750              	.LASF21:
 3751 0272 646D6163 		.ascii	"dmac_tdmem\000"
 3751      5F74646D 
 3751      656D00
 3752              	.LASF49:
 3753 027d 63436861 		.ascii	"cCharsReceived\000"
 3753      72735265 
 3753      63656976 
 3753      656400
 3754              	.LASF22:
 3755 028c 73746174 		.ascii	"status\000"
 3755      757300
 3756              	.LASF65:
 3757 0293 44696769 		.ascii	"Digital_Input_Status_Last\000"
 3757      74616C5F 
 3757      496E7075 
 3757      745F5374 
 3757      61747573 
 3758              	.LASF17:
 3759 02ad 63686172 		.ascii	"char\000"
 3759      00
 3760              	.LASF4:
 3761 02b2 6C6F6E67 		.ascii	"long int\000"
 3761      20696E74 
 3761      00
 3762              	.LASF33:
 3763 02bb 6D61696E 		.ascii	"main\000"
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 87


 3763      00
 3764              	.LASF10:
 3765 02c0 696E7433 		.ascii	"int32_t\000"
 3765      325F7400 
 3766              	.LASF64:
 3767 02c8 77617665 		.ascii	"wave_offset\000"
 3767      5F6F6666 
 3767      73657400 
 3768              	.LASF3:
 3769 02d4 73686F72 		.ascii	"short unsigned int\000"
 3769      7420756E 
 3769      7369676E 
 3769      65642069 
 3769      6E7400
 3770              	.LASF11:
 3771 02e7 75696E74 		.ascii	"uint8\000"
 3771      3800
 3772              	.LASF51:
 3773 02ed 69526561 		.ascii	"iRead\000"
 3773      6400
 3774              	.LASF66:
 3775 02f3 44696769 		.ascii	"Digital_AutoUpdate\000"
 3775      74616C5F 
 3775      4175746F 
 3775      55706461 
 3775      746500
 3776              	.LASF13:
 3777 0306 75696E74 		.ascii	"uint32\000"
 3777      333200
 3778              	.LASF68:
 3779 030d 6D61696E 		.ascii	"main.c\000"
 3779      2E6300
 3780              	.LASF18:
 3781 0314 72656738 		.ascii	"reg8\000"
 3781      00
 3782              	.LASF5:
 3783 0319 6C6F6E67 		.ascii	"long unsigned int\000"
 3783      20756E73 
 3783      69676E65 
 3783      6420696E 
 3783      7400
 3784              	.LASF14:
 3785 032b 696E7433 		.ascii	"int32\000"
 3785      3200
 3786              	.LASF16:
 3787 0331 646F7562 		.ascii	"double\000"
 3787      6C6500
 3788              	.LASF37:
 3789 0338 63684861 		.ascii	"chHandle\000"
 3789      6E646C65 
 3789      00
 3790              	.LASF9:
 3791 0341 5F5F696E 		.ascii	"__int32_t\000"
 3791      7433325F 
 3791      7400
 3792              	.LASF69:
 3793 034b 433A5C53 		.ascii	"C:\\SVN\\apps\\trunk\\Cypress Academy\\PSoC-121-Ana"
ARM GAS  C:\Users\Greg\AppData\Local\Temp\ccE78A4N.s 			page 88


 3793      564E5C61 
 3793      7070735C 
 3793      7472756E 
 3793      6B5C4379 
 3794 0379 6C6F675C 		.ascii	"log\\Scope\\ScopePSoC\\Scope.cydsn\000"
 3794      53636F70 
 3794      655C5363 
 3794      6F706550 
 3794      536F435C 
 3795              	.LASF56:
 3796 0399 70726561 		.ascii	"preamp_a\000"
 3796      6D705F61 
 3796      00
 3797              	.LASF57:
 3798 03a2 70726561 		.ascii	"preamp_b\000"
 3798      6D705F62 
 3798      00
 3799              	.LASF50:
 3800 03ab 737A436F 		.ascii	"szCommandsBuffer\000"
 3800      6D6D616E 
 3800      64734275 
 3800      66666572 
 3800      00
 3801              	.LASF36:
 3802 03bc 50757453 		.ascii	"PutString\000"
 3802      7472696E 
 3802      6700
 3803              	.LASF35:
 3804 03c6 52656365 		.ascii	"ReceivedBytes\000"
 3804      69766564 
 3804      42797465 
 3804      7300
 3805              	.LASF41:
 3806 03d4 49544D5F 		.ascii	"ITM_RxBuffer\000"
 3806      52784275 
 3806      66666572 
 3806      00
 3807              	.LASF47:
 3808 03e1 4368616E 		.ascii	"Channel_2_Data\000"
 3808      6E656C5F 
 3808      325F4461 
 3808      746100
 3809              	.LASF43:
 3810 03f0 444D415F 		.ascii	"DMA_Channel_1_TD\000"
 3810      4368616E 
 3810      6E656C5F 
 3810      315F5444 
 3810      00
 3811              	.LASF25:
 3812 0401 62766172 		.ascii	"bvar\000"
 3812      00
 3813              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
